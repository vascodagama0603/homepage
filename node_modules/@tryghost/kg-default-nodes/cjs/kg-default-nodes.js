'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lexical = require('lexical');
var cleanBasicHtml = require('@tryghost/kg-clean-basic-html');
var markdownHtmlRenderer = require('@tryghost/kg-markdown-html-renderer');
var luxon = require('luxon');
var lodash = require('lodash');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var cleanBasicHtml__default = /*#__PURE__*/_interopDefaultLegacy(cleanBasicHtml);
var markdownHtmlRenderer__default = /*#__PURE__*/_interopDefaultLegacy(markdownHtmlRenderer);

class KoenigDecoratorNode extends lexical.DecoratorNode {}

function $isKoenigCard(node) {
    return node instanceof KoenigDecoratorNode;
}

function buildCleanBasicHtmlForElement(domNode) {
    return function _cleanBasicHtml(html) {
        const cleanedHtml = cleanBasicHtml__default["default"](html, {
            createDocument: (_html) => {
                const newDoc = domNode.ownerDocument.implementation.createHTMLDocument();
                newDoc.body.innerHTML = _html;
                return newDoc;
            }
        });
        return cleanedHtml;
    };
}

function readCaptionFromElement(element, {selector = 'figcaption'} = {}) {
    const cleanBasicHtml = buildCleanBasicHtmlForElement(element);

    let caption;

    const figcaptions = Array.from(element.querySelectorAll(selector));
    if (figcaptions.length) {
        figcaptions.forEach((figcaption) => {
            const cleanHtml = cleanBasicHtml(figcaption.innerHTML);
            caption = caption ? `${caption} / ${cleanHtml}` : cleanHtml;
        });
    }

    return caption;
}

function readImageAttributesFromElement(element) {
    const attrs = {};

    if (element.src) {
        attrs.src = element.src;
    }

    if (element.width) {
        attrs.width = element.width;
    } else if (element.dataset && element.dataset.width) {
        attrs.width = parseInt(element.dataset.width, 10);
    }

    if (element.height) {
        attrs.height = element.height;
    } else if (element.dataset && element.dataset.height) {
        attrs.height = parseInt(element.dataset.height, 10);
    }

    if ((!element.width && !element.height) && element.getAttribute('data-image-dimensions')) {
        const [, width, height] = (/^(\d*)x(\d*)$/gi).exec(element.getAttribute('data-image-dimensions'));
        attrs.width = parseInt(width, 10);
        attrs.height = parseInt(height, 10);
    }

    if (element.alt) {
        attrs.alt = element.alt;
    }

    if (element.title) {
        attrs.title = element.title;
    }

    if (element.parentNode.tagName === 'A') {
        const href = element.parentNode.href;

        if (href !== attrs.src) {
            attrs.href = href;
        }
    }

    return attrs;
}

class ImageParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            img: () => ({
                conversion(domNode) {
                    if (domNode.tagName === 'IMG') {
                        const {src, width, height, alt, title} = readImageAttributesFromElement(domNode);

                        const node = new self.NodeClass({alt, src, title, width, height});
                        return {node};
                    }

                    return null;
                },
                priority: 1
            }),
            figure: (nodeElem) => {
                if (!nodeElem.querySelector('img')) {
                    return null;
                }
                return {
                    conversion(domNode) {
                        const img = domNode.querySelector('img');
                        const kgClass = domNode.className.match(/kg-width-(wide|full)/);
                        const grafClass = domNode.className.match(/graf--layout(FillWidth|OutsetCenter)/);

                        if (!img) {
                            return null;
                        }

                        const payload = readImageAttributesFromElement(img);

                        if (kgClass) {
                            payload.cardWidth = kgClass[1];
                        } else if (grafClass) {
                            payload.cardWidth = grafClass[1] === 'FillWidth' ? 'full' : 'wide';
                        }

                        payload.caption = readCaptionFromElement(domNode);

                        const {src, width, height, alt, title, caption, cardWidth, href} = payload;
                        const node = new self.NodeClass({alt, src, title, width, height, caption, cardWidth, href});
                        return {node};
                    },
                    priority: 1
                };
            }
        };
    }
}

const getAvailableImageWidths = function (image, imageSizes) {
    // get a sorted list of the available responsive widths
    const imageWidths = Object.values(imageSizes)
        .map(({width}) => width)
        .sort((a, b) => a - b);

    // select responsive widths that are usable based on the image width
    const availableImageWidths = imageWidths
        .filter(width => width <= image.width);

    // add the original image size to the responsive list if it's not captured by largest responsive size
    // - we can't know the width/height of the original `src` image because we don't know if it was resized
    //   or not. Adding the original image to the responsive list ensures we're not showing smaller sized
    //   images than we need to be
    if (image.width > availableImageWidths[availableImageWidths.length - 1] && image.width < imageWidths[imageWidths.length - 1]) {
        availableImageWidths.push(image.width);
    }

    return availableImageWidths;
};

const isLocalContentImage = function (url, siteUrl = '') {
    const normalizedSiteUrl = siteUrl.replace(/\/$/, '');
    const imagePath = url.replace(normalizedSiteUrl, '');
    return /^(\/.*|__GHOST_URL__)\/?content\/images\//.test(imagePath);
};

const isUnsplashImage = function (url) {
    return /images\.unsplash\.com/.test(url);
};

// default content sizes: [600, 1000, 1600, 2400]

const getSrcsetAttribute = function ({src, width, options}) {
    if (!options.imageOptimization || options.imageOptimization.srcsets === false || !width || !options.imageOptimization.contentImageSizes) {
        return;
    }

    if (isLocalContentImage(src, options.siteUrl) && options.canTransformImage && !options.canTransformImage(src)) {
        return;
    }

    const srcsetWidths = getAvailableImageWidths({width}, options.imageOptimization.contentImageSizes);

    // apply srcset if this is a relative image that matches Ghost's image url structure
    if (isLocalContentImage(src, options.siteUrl)) {
        const [, imagesPath, filename] = src.match(/(.*\/content\/images)\/(.*)/);
        const srcs = [];

        srcsetWidths.forEach((srcsetWidth) => {
            if (srcsetWidth === width) {
                // use original image path if width matches exactly (avoids 302s from size->original)
                srcs.push(`${src} ${srcsetWidth}w`);
            } else if (srcsetWidth <= width) {
                // avoid creating srcset sizes larger than intrinsic image width
                srcs.push(`${imagesPath}/size/w${srcsetWidth}/${filename} ${srcsetWidth}w`);
            }
        });

        if (srcs.length) {
            return srcs.join(', ');
        }
    }

    // apply srcset if this is an Unsplash image
    if (isUnsplashImage(src)) {
        const unsplashUrl = new URL(src);
        const srcs = [];

        srcsetWidths.forEach((srcsetWidth) => {
            unsplashUrl.searchParams.set('w', srcsetWidth);
            srcs.push(`${unsplashUrl.href} ${srcsetWidth}w`);
        });

        return srcs.join(', ');
    }
};

const setSrcsetAttribute = function (elem, image, options) {
    if (!elem || !['IMG', 'SOURCE'].includes(elem.tagName) || !elem.getAttribute('src') || !image) {
        return;
    }

    const {src, width} = image;
    const srcset = getSrcsetAttribute({src, width, options});

    if (srcset) {
        elem.setAttribute('srcset', srcset);
    }
};

const resizeImage = function (image, {width: desiredWidth, height: desiredHeight} = {}) {
    const {width, height} = image;
    const ratio = width / height;

    if (desiredWidth) {
        const resizedHeight = Math.round(desiredWidth / ratio);

        return {
            width: desiredWidth,
            height: resizedHeight
        };
    }

    if (desiredHeight) {
        const resizedWidth = Math.round(desiredHeight * ratio);

        return {
            width: resizedWidth,
            height: desiredHeight
        };
    }
};

// If we're in a browser environment, we can use the global document object,
// but if we're in a non-browser environment, we need to be passed a `createDocument` function
function addCreateDocumentOption(options) {
    if (!options.createDocument) {
        /* c8 ignore start */
        let document = typeof window !== 'undefined' && window.document;

        if (!document) {
            throw new Error('renderImageNodeToDOM() must be passed a `createDocument` function as an option when used in a non-browser environment'); // eslint-disable-line
        }

        options.createDocument = function () {
            return document;
        };
        /* c8 ignore end */
    }
}

function renderImageNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getSrc() || node.getSrc().trim() === '') {
        return document.createTextNode('');
    }

    const figure = document.createElement('figure');

    let figureClasses = 'kg-card kg-image-card';
    if (node.getCardWidth() !== 'regular') {
        figureClasses += ` kg-width-${node.getCardWidth()}`;
    }

    figure.setAttribute('class', figureClasses);

    const img = document.createElement('img');
    img.setAttribute('src', node.getSrc());
    img.setAttribute('alt', node.getAlt());
    img.setAttribute('loading', 'lazy');

    if (node.getTitle()) {
        img.setAttribute('title', node.getTitle());
    }

    if (node.getImgWidth() && node.getImgHeight()) {
        img.setAttribute('width', node.getImgWidth());
        img.setAttribute('height', node.getImgHeight());
    }

    // images can be resized to max width, if that's the case output
    // the resized width/height attrs to ensure 3rd party gallery plugins
    // aren't affected by differing sizes
    const {canTransformImage} = options;
    const {defaultMaxWidth} = options.imageOptimization || {};
    if (
        defaultMaxWidth &&
            node.getImgWidth() > defaultMaxWidth &&
            isLocalContentImage(node.getSrc(), options.siteUrl) &&
            canTransformImage &&
            canTransformImage(node.getSrc())
    ) {
        const imageDimensions = {
            width: node.getImgWidth(),
            height: node.getImgHeight()
        };
        const {width, height} = resizeImage(imageDimensions, {width: defaultMaxWidth});
        img.setAttribute('width', width);
        img.setAttribute('height', height);
    }

    if (options.target !== 'email') {
        const imgAttributes = {
            src: node.getSrc(),
            width: node.getImgWidth(),
            height: node.getImgHeight()
        };
        setSrcsetAttribute(img, imgAttributes, options);

        if (img.getAttribute('srcset') && node.getImgWidth() && node.getImgWidth() >= 720) {
            // standard size
            if (!node.getCardWidth() || node.getCardWidth() === 'regular') {
                img.setAttribute('sizes', '(min-width: 720px) 720px');
            }

            if (node.getCardWidth() === 'wide' && node.getImgWidth() >= 1200) {
                img.setAttribute('sizes', '(min-width: 1200px) 1200px');
            }
        }
    }

    // Outlook is unable to properly resize images without a width/height
    // so we add that at the expected size in emails (600px) and use a higher
    // resolution image to keep images looking good on retina screens
    if (options.target === 'email' && node.getImgWidth() && node.getImgHeight()) {
        let imageDimensions = {
            width: node.getImgWidth(),
            height: node.getImgHeight()
        };
        if (node.getImgWidth() >= 600) {
            imageDimensions = resizeImage(imageDimensions, {width: 600});
        }
        img.setAttribute('width', imageDimensions.width);
        img.setAttribute('height', imageDimensions.height);

        if (isLocalContentImage(node.getSrc(), options.siteUrl) && options.canTransformImage?.(node.getSrc())) {
            // find available image size next up from 2x600 so we can use it for the "retina" src
            const availableImageWidths = getAvailableImageWidths(node, options.imageOptimization.contentImageSizes);
            const srcWidth = availableImageWidths.find(width => width >= 1200);

            if (!srcWidth || srcWidth === node.getImgWidth()) ; else {
                const [, imagesPath, filename] = node.getSrc().match(/(.*\/content\/images)\/(.*)/);
                img.setAttribute('src', `${imagesPath}/size/w${srcWidth}/${filename}`);
            }
        }
    }

    if (node.getHref()) {
        const a = document.createElement('a');
        a.setAttribute('href', node.getHref());
        a.appendChild(img);
        figure.appendChild(a);
    } else {
        figure.appendChild(img);
    }

    if (node.getCaption()) {
        const caption = document.createElement('figcaption');
        caption.innerHTML = node.getCaption();
        figure.appendChild(caption);
    }

    return figure;
}

const INSERT_IMAGE_COMMAND = lexical.createCommand();
const UPLOAD_IMAGE_COMMAND = lexical.createCommand();

class ImageNode extends KoenigDecoratorNode {
    // payload properties
    __src;
    __caption;
    __title;
    __alt;
    __cardWidth;
    __width;
    __height;
    __href;

    static getType() {
        return 'image';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            src: 'url',
            href: 'url',
            caption: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            src: self.__src,
            caption: self.__caption,
            title: self.__title,
            alt: self.__alt,
            width: self.__width,
            height: self.__height,
            cardWidth: self.__cardWidth,
            href: self.__href
        };
    }

    constructor({src, caption, title, alt, cardWidth, width, height, href} = {}, key) {
        super(key);
        this.__src = src || '';
        this.__title = title || '';
        this.__caption = caption || '';
        this.__alt = alt || '';
        this.__width = width || null;
        this.__height = height || null;
        this.__cardWidth = cardWidth || 'regular';
        this.__href = href || '';
    }

    static importJSON(serializedNode) {
        const {src, caption, title, alt, width, height, cardWidth, href} = serializedNode;
        const node = new this({
            src,
            caption,
            title,
            alt,
            width,
            height,
            href,
            cardWidth
        });
        return node;
    }

    exportJSON() {
        // checks if src is a data string
        const src = this.getSrc();
        const isBlob = src.startsWith('data:');
        const dataset = {
            type: 'image',
            version: 1,
            src: isBlob ? '<base64String>' : this.getSrc(),
            width: this.getImgWidth(),
            height: this.getImgHeight(),
            title: this.getTitle(),
            alt: this.getAlt(),
            caption: this.getCaption(),
            cardWidth: this.getCardWidth(),
            href: this.getHref()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new ImageParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderImageNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getSrc() {
        const self = this.getLatest();
        return self.__src;
    }

    setSrc(src) {
        const writable = this.getWritable();
        return writable.__src = src;
    }

    getTitle() {
        const self = this.getLatest();
        return self.__title;
    }

    setTitle(title) {
        const writable = this.getWritable();
        return writable.__title = title;
    }

    getHref() {
        const self = this.getLatest();
        return self.__href;
    }

    setHref(href) {
        const writable = this.getWritable();
        return writable.__href = href;
    }

    setCardWidth(cardWidth) {
        const writable = this.getWritable();
        return writable.__cardWidth = cardWidth;
    }

    getCardWidth() {
        const self = this.getLatest();
        return self.__cardWidth;
    }

    getImgWidth() {
        const self = this.getLatest();
        return self.__width;
    }

    setImgWidth(width) {
        const writable = this.getWritable();
        return writable.__width = width;
    }

    getImgHeight() {
        const self = this.getLatest();
        return self.__height;
    }

    setImgHeight(height) {
        const writable = this.getWritable();
        return writable.__height = height;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    getAlt() {
        const self = this.getLatest();
        return self.__alt;
    }

    setAlt(alt) {
        const writable = this.getWritable();
        return writable.__alt = alt;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createImageNode = (dataset) => {
    return new ImageNode(dataset);
};

function $isImageNode(node) {
    return node instanceof ImageNode;
}

class CodeBlockParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            figure: () => ({
                conversion(domNode) {
                    if (domNode.tagName === 'FIGURE') {
                        const pre = domNode.querySelector('pre');

                        // If this figure doesn't have a pre tag in it
                        if (!pre) {
                            return null;
                        }

                        let code = pre.querySelector('code');
                        let figcaption = domNode.querySelector('figcaption');

                        // if there's no caption the pre key should pick it up
                        if (!code || !figcaption) {
                            return null;
                        }

                        let payload = {
                            code: code.textContent,
                            caption: readCaptionFromElement(domNode)
                        };

                        let preClass = pre.getAttribute('class') || '';
                        let codeClass = code.getAttribute('class') || '';
                        let langRegex = /lang(?:uage)?-(.*?)(?:\s|$)/i;
                        let languageMatches = preClass.match(langRegex) || codeClass.match(langRegex);
                        if (languageMatches) {
                            payload.language = languageMatches[1].toLowerCase();
                        }

                        const node = new self.NodeClass(payload);
                        return {node};
                    }
                    return null;
                },
                priority: 2 // falls back to pre if no caption
            }),
            pre: () => ({
                conversion(domNode) {
                    if (domNode.tagName === 'PRE') {
                        let [codeElement] = domNode.children;

                        if (codeElement && codeElement.tagName === 'CODE') {
                            let payload = {code: codeElement.textContent};
                            let preClass = domNode.getAttribute('class') || '';
                            let codeClass = codeElement.getAttribute('class') || '';
                            let langRegex = /lang(?:uage)?-(.*?)(?:\s|$)/i;
                            let languageMatches = preClass.match(langRegex) || codeClass.match(langRegex);
                            if (languageMatches) {
                                payload.language = languageMatches[1].toLowerCase();
                            }
                            const node = new self.NodeClass(payload);
                            return {node};
                        }
                    }

                    return null;
                },
                priority: 1
            })
        };
    }
}

function renderCodeBlockNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getCode() || node.getCode().trim() === '') {
        return document.createTextNode('');
    }

    const pre = document.createElement('pre');
    const code = document.createElement('code');

    if (node.getLanguage()) {
        code.setAttribute('class', `language-${node.getLanguage()}`);
    }

    code.appendChild(document.createTextNode(node.getCode()));
    pre.appendChild(code);

    if (node.getCaption()) {
        let figure = document.createElement('figure');
        figure.setAttribute('class', 'kg-card kg-code-card');
        figure.appendChild(pre);

        let figcaption = document.createElement('figcaption');
        figcaption.appendChild(document.createTextNode(node.getCaption()));
        figure.appendChild(figcaption);

        return figure;
    } else {
        return pre;
    }
}

const INSERT_CODE_BLOCK_COMMAND = lexical.createCommand();

class CodeBlockNode extends KoenigDecoratorNode {
    __code;
    __language;
    __caption;

    static getType() {
        return 'codeblock';
    }

    static clone(node) {
        // must use `this` so the extended class in the Editor uses the correct class when cloning
        // without needing to override this method
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            caption: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            code: self.__code,
            language: self.__language,
            caption: self.__caption
        };
    }

    static importJSON(serializedNode) {
        const {code, language, caption} = serializedNode;
        const node = new this({code, language, caption});
        return node;
    }

    exportJSON() {
        return {
            type: 'codeblock',
            version: 1,
            code: this.__code,
            language: this.__language,
            caption: this.__caption
        };
    }

    constructor({code, language, caption} = {}, key) {
        super(key);
        this.__code = code;
        this.__language = language;
        this.__caption = caption;
    }

    static importDOM() {
        const parser = new CodeBlockParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderCodeBlockNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const self = this.getWritable();
        self.__caption = caption;
    }

    getCode() {
        const self = this.getLatest();
        return self.__code;
    }

    setCode(code) {
        const self = this.getWritable();
        self.__code = code;
    }

    getLanguage() {
        const self = this.getLatest();
        return self.__language;
    }

    setLanguage(language) {
        const self = this.getWritable();
        self.__language = language;
    }

    getTextContent() {
        const self = this.getLatest();
        return self.__code;
    }

    // should be overwritten
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__code;
    }
}

function $createCodeBlockNode(dataset) {
    return new CodeBlockNode(dataset);
}

function $isCodeBlockNode(node) {
    return node instanceof CodeBlockNode;
}

function renderMarkdownNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const html = markdownHtmlRenderer__default["default"].render(node.getMarkdown() || '', options);

    const div = document.createElement('div');

    div.innerHTML = html;

    return div;
}

const INSERT_MARKDOWN_COMMAND = lexical.createCommand();

class MarkdownNode extends KoenigDecoratorNode {
    __markdown;

    static getType() {
        return 'markdown';
    }

    static clone(node) {
        return new this(node.getDataset(), node.__key);
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            markdown: 'markdown'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            markdown: self.__markdown
        };
    }

    static importJSON(serializedNode) {
        const {markdown} = serializedNode;
        const node = new this({markdown});
        return node;
    }

    exportJSON() {
        return {
            type: 'markdown',
            version: 1,
            markdown: this.getMarkdown()
        };
    }

    constructor({markdown} = {}, key) {
        super(key);
        this.__markdown = markdown;
    }

    exportDOM(options = {}) {
        const element = renderMarkdownNodeToDOM(this, options);
        return {
            element,
            type: 'inner'
        };
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getMarkdown() {
        return this.__markdown;
    }

    setMarkdown(markdown) {
        const writable = this.getWritable();
        return writable.__markdown = markdown;
    }

    // should be overwritten
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__markdown;
    }
}

function $createMarkdownNode(dataset) {
    return new MarkdownNode(dataset);
}

function $isMarkdownNode(node) {
    return node instanceof MarkdownNode;
}

class VideoParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            figure: () => ({
                conversion(domNode) {
                    const isKgVideoCard = domNode.classList?.contains('kg-video-card');
                    if (domNode.tagName === 'FIGURE' && isKgVideoCard) {
                        const videoNode = domNode.querySelector('.kg-video-container video');
                        const durationNode = domNode.querySelector('.kg-video-duration');
                        const videoSrc = videoNode && videoNode.src;
                        const videoWidth = videoNode && videoNode.width;
                        const videoHeight = videoNode && videoNode.height;
                        const durationText = durationNode && durationNode.innerHTML.trim();
                        const captionText = readCaptionFromElement(domNode);

                        if (!videoSrc) {
                            return null;
                        }

                        const payload = {
                            src: videoSrc,
                            loop: !!videoNode.loop,
                            cardWidth: getCardWidth(videoNode)
                        };

                        if (durationText) {
                            const [minutes, seconds] = durationText.split(':');
                            try {
                                payload.duration = parseInt(minutes) * 60 + parseInt(seconds);
                            } catch (e) {
                                // ignore duration
                            }
                        }

                        if (domNode.dataset.kgThumbnail) {
                            payload.thumbnailSrc = domNode.dataset.kgThumbnail;
                        }

                        if (domNode.dataset.kgCustomThumbnail) {
                            payload.customThumbnailSrc = domNode.dataset.kgCustomThumbnail;
                        }

                        if (captionText) {
                            payload.caption = captionText;
                        }

                        if (videoWidth) {
                            payload.width = videoWidth;
                        }

                        if (videoHeight) {
                            payload.height = videoHeight;
                        }

                        const node = new self.NodeClass(payload);
                        return {node};
                    }

                    return null;
                },
                priority: 1
            })
        };
    }
}

function getCardWidth(domNode) {
    if (domNode.classList.contains('kg-width-full')) {
        return 'full';
    } else if (domNode.classList.contains('kg-width-wide')) {
        return 'wide';
    } else {
        return 'regular';
    }
}

function renderVideoNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getSrc() || node.getSrc().trim() === '') {
        return document.createTextNode('');
    }

    const cardClasses = getCardClasses$2(node).join(' ');

    const htmlString = options.target === 'email'
        ? emailCardTemplate$2({node, options, cardClasses})
        : cardTemplate$3({node, cardClasses});

    const element = document.createElement('div');
    element.innerHTML = htmlString.trim();

    return element.firstElementChild;
}

function cardTemplate$3({node, cardClasses}) {
    const width = node.getVideoWidth();
    const height = node.getVideoHeight();
    const posterSpacerSrc = `https://img.spacergif.org/v1/${width}x${height}/0a/spacer.png`;
    const autoplayAttr = node.getLoop() ? 'loop autoplay muted' : '';
    const thumbnailSrc = node.getCustomThumbnailSrc() || node.getThumbnailSrc();
    const hideControlsClass = node.getLoop() ? ' kg-video-hide' : '';

    return (
        `
        <figure class="${cardClasses}" data-kg-thumbnail=${node.getThumbnailSrc()} data-kg-custom-thumbnail=${node.getCustomThumbnailSrc()}>
            <div class="kg-video-container">
                <video
                    src="${node.getSrc()}"
                    poster="${posterSpacerSrc}"
                    width="${width}"
                    height="${height}"
                    ${autoplayAttr}
                    playsinline
                    preload="metadata"
                    style="background: transparent url('${thumbnailSrc}') 50% 50% / cover no-repeat;"
                ></video>
                <div class="kg-video-overlay">
                    <button class="kg-video-large-play-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z"/>
                        </svg>
                    </button>
                </div>
                <div class="kg-video-player-container${hideControlsClass}">
                    <div class="kg-video-player">
                        <button class="kg-video-play-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z"></path>
                            </svg>
                        </button>
                        <button class="kg-video-pause-icon kg-video-hide">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <rect x="3" y="1" width="7" height="22" rx="1.5" ry="1.5"></rect>
                                <rect x="14" y="1" width="7" height="22" rx="1.5" ry="1.5"></rect>
                            </svg>
                        </button>
                        <span class="kg-video-current-time">0:00</span>
                        <div class="kg-video-time">
                            /<span class="kg-video-duration">${node.getFormattedDuration()}</span>
                        </div>
                        <input type="range" class="kg-video-seek-slider" max="100" value="0">
                        <button class="kg-video-playback-rate">1&#215;</button>
                        <button class="kg-video-unmute-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M15.189 2.021a9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1.794a.249.249 0 0 1 .221.133 9.73 9.73 0 0 0 7.924 4.85h.06a1 1 0 0 0 1-1V3.02a1 1 0 0 0-1.06-.998Z"></path>
                            </svg>
                        </button>
                        <button class="kg-video-mute-icon kg-video-hide">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path d="M16.177 4.3a.248.248 0 0 0 .073-.176v-1.1a1 1 0 0 0-1.061-1 9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h.114a.251.251 0 0 0 .177-.073ZM23.707 1.706A1 1 0 0 0 22.293.292l-22 22a1 1 0 0 0 0 1.414l.009.009a1 1 0 0 0 1.405-.009l6.63-6.631A.251.251 0 0 1 8.515 17a.245.245 0 0 1 .177.075 10.081 10.081 0 0 0 6.5 2.92 1 1 0 0 0 1.061-1V9.266a.247.247 0 0 1 .073-.176Z"></path>
                            </svg>
                        </button>
                        <input type="range" class="kg-video-volume-slider" max="100" value="100"/>
                    </div>
                </div>
            </div>
            ${node.getCaption() ? `<figcaption>${node.getCaption()}</figcaption>` : ''}
        </figure>
    `
    );
}

function emailCardTemplate$2({node, options, cardClasses}) {
    const thumbnailSrc = node.getCustomThumbnailSrc() || node.getThumbnailSrc();
    const emailTemplateMaxWidth = 600;
    const aspectRatio = node.getVideoWidth() / node.getVideoHeight();
    const emailSpacerWidth = Math.round(emailTemplateMaxWidth / 4);
    const emailSpacerHeight = Math.round(emailTemplateMaxWidth / aspectRatio);
    const posterSpacerSrc = `https://img.spacergif.org/v1/${emailSpacerWidth}x${emailSpacerHeight}/0a/spacer.png`;
    const outlookCircleLeft = Math.round((emailTemplateMaxWidth / 2) - 39);
    const outlookCircleTop = Math.round((emailSpacerHeight / 2) - 39);
    const outlookPlayLeft = Math.round((emailTemplateMaxWidth / 2) - 11);
    const outlookPlayTop = Math.round((emailSpacerHeight / 2) - 17);

    return (
        `
         <figure class="${cardClasses}">
            <!--[if !mso !vml]-->
            <a class="kg-video-preview" href="${options.postUrl}" aria-label="Play video" style="mso-hide: all">
                <table
                    cellpadding="0"
                    cellspacing="0"
                    border="0"
                    width="100%"
                    background="${thumbnailSrc}"
                    role="presentation"
                    style="background: url('${thumbnailSrc}') left top / cover; mso-hide: all"
                >
                    <tr style="mso-hide: all">
                        <td width="25%" style="visibility: hidden; mso-hide: all">
                            <img src="${posterSpacerSrc}" alt="" width="100%" border="0" style="height: auto; opacity: 0; visibility: hidden; mso-hide: all;">
                        </td>
                        <td width="50%" align="center" valign="middle" style="vertical-align: middle; mso-hide: all;">
                            <div class="kg-video-play-button" style="mso-hide: all"><div style="mso-hide: all"></div></div>
                        </td>
                        <td width="25%" style="mso-hide: all">&nbsp;</td>
                    </tr>
                </table>
            </a>
            <!--[endif]-->

            <!--[if vml]>
            <v:group xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" coordsize="${emailTemplateMaxWidth},${emailSpacerHeight}" coordorigin="0,0" href="${options.postUrl}" style="width:${emailTemplateMaxWidth}px;height:${emailSpacerHeight}px;">
                <v:rect fill="t" stroked="f" style="position:absolute;width:${emailTemplateMaxWidth};height:${emailSpacerHeight};"><v:fill src="${thumbnailSrc}" type="frame"/></v:rect>
                <v:oval fill="t" strokecolor="white" strokeweight="4px" style="position:absolute;left:${outlookCircleLeft};top:${outlookCircleTop};width:78;height:78"><v:fill color="black" opacity="30%" /></v:oval>
                <v:shape coordsize="24,32" path="m,l,32,24,16,xe" fillcolor="white" stroked="f" style="position:absolute;left:${outlookPlayLeft};top:${outlookPlayTop};width:30;height:34;" />
            </v:group>
            <![endif]-->

            ${node.getCaption() ? `<figcaption>${node.getCaption()}</figcaption>` : ''}
        </figure>
        `
    );
}

function getCardClasses$2(node) {
    let cardClasses = ['kg-card kg-video-card'];

    if (node.getCardWidth()) {
        cardClasses.push(`kg-width-${node.getCardWidth()}`);
    }
    if (node.getCaption()) {
        cardClasses.push(`kg-card-hascaption`);
    }

    return cardClasses;
}

const INSERT_VIDEO_COMMAND = lexical.createCommand();
const NODE_TYPE$9 = 'video';

class VideoNode extends KoenigDecoratorNode {
    // payload properties
    __src;
    __caption;
    __fileName;
    __mimeType;
    __width;
    __height;
    __duration;
    __thumbnailSrc;
    __customThumbnailSrc;
    __thumbnailWidth;
    __thumbnailHeight;
    __cardWidth;
    __loop;

    static getType() {
        return NODE_TYPE$9;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            src: 'url',
            thumbnailSrc: 'url',
            customThumbnailSrc: 'url',
            caption: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            src: self.__src,
            caption: self.__caption,
            fileName: self.__fileName,
            mimeType: self.__mimeType,
            width: self.__width,
            height: self.__height,
            duration: self.__duration,
            thumbnailSrc: self.__thumbnailSrc,
            customThumbnailSrc: self.__customThumbnailSrc,
            thumbnailWidth: self.__thumbnailWidth,
            thumbnailHeight: self.__thumbnailHeight,
            cardWidth: self.__cardWidth,
            loop: self.__loop
        };
    }

    constructor({src, caption, fileName, mimeType, width, height, duration, thumbnailSrc, customThumbnailSrc, thumbnailWidth, thumbnailHeight, cardWidth, loop} = {}, key) {
        super(key);
        this.__src = src || '';
        this.__caption = caption || '';
        this.__fileName = fileName || '';
        this.__mimeType = mimeType || '';
        this.__width = width || null;
        this.__height = height || null;
        this.__duration = duration || 0;
        this.__thumbnailSrc = thumbnailSrc || '';
        this.__customThumbnailSrc = customThumbnailSrc || '';
        this.__thumbnailWidth = thumbnailWidth || null;
        this.__thumbnailHeight = thumbnailHeight || null;
        this.__cardWidth = cardWidth || 'regular';
        this.__loop = !!loop;
    }

    static importJSON(serializedNode) {
        const {src, caption, fileName, mimeType, width, height, duration, thumbnailSrc, customThumbnailSrc, thumbnailWidth, thumbnailHeight, cardWidth, loop} = serializedNode;
        const node = new this({
            src,
            caption,
            fileName,
            mimeType,
            width,
            height,
            duration,
            thumbnailSrc,
            customThumbnailSrc,
            thumbnailWidth,
            thumbnailHeight,
            cardWidth,
            loop
        });
        return node;
    }

    exportJSON() {
        // checks if src is a data string
        const src = this.getSrc();
        const isBlob = src.startsWith('data:');
        const dataset = {
            type: NODE_TYPE$9,
            version: 1,
            src: isBlob ? '<base64String>' : this.getSrc(),
            caption: this.getCaption(),
            fileName: this.getFileName(),
            mimeType: this.getMimeType(),
            width: this.getVideoWidth(),
            height: this.getVideoHeight(),
            duration: this.getDuration(),
            thumbnailSrc: this.getThumbnailSrc(),
            customThumbnailSrc: this.getCustomThumbnailSrc(),
            thumbnailWidth: this.getThumbnailWidth(),
            thumbnailHeight: this.getThumbnailHeight(),
            cardWidth: this.getCardWidth(),
            loop: this.getLoop()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new VideoParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderVideoNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getSrc() {
        const self = this.getLatest();
        return self.__src;
    }

    setSrc(src) {
        const writable = this.getWritable();
        return writable.__src = src;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    getFileName() {
        const self = this.getLatest();
        return self.__fileName;
    }

    setFileName(fileName) {
        const writable = this.getWritable();
        return writable.__fileName = fileName;
    }

    getMimeType() {
        const self = this.getLatest();
        return self.__mimeType;
    }

    setMimeType(mimeType) {
        const writable = this.getWritable();
        return writable.__mimeType = mimeType;
    }

    getVideoWidth() {
        const self = this.getLatest();
        return self.__width;
    }

    setVideoWidth(width) {
        const writable = this.getWritable();
        return writable.__width = width;
    }

    getVideoHeight() {
        const self = this.getLatest();
        return self.__height;
    }

    setVideoHeight(height) {
        const writable = this.getWritable();
        return writable.__height = height;
    }

    getDuration() {
        const self = this.getLatest();
        return self.__duration;
    }

    getFormattedDuration() {
        const minutes = Math.floor(this.getDuration() / 60);
        const seconds = Math.floor(this.getDuration() - (minutes * 60));
        const paddedSeconds = String(seconds).padStart(2, '0');
        const formattedDuration = `${minutes}:${paddedSeconds}`;
        return formattedDuration;
    }

    setDuration(duration) {
        const writable = this.getWritable();
        return writable.__duration = duration;
    }

    getThumbnailSrc() {
        const self = this.getLatest();
        return self.__thumbnailSrc;
    }

    setThumbnailSrc(thumbnailSrc) {
        const writable = this.getWritable();
        return writable.__thumbnailSrc = thumbnailSrc;
    }

    getCustomThumbnailSrc() {
        const self = this.getLatest();
        return self.__customThumbnailSrc;
    }

    setCustomThumbnailSrc(customThumbnailSrc) {
        const writable = this.getWritable();
        return writable.__customThumbnailSrc = customThumbnailSrc;
    }

    getThumbnailWidth() {
        const self = this.getLatest();
        return self.__thumbnailWidth;
    }

    setThumbnailWidth(thumbnailWidth) {
        const writable = this.getWritable();
        return writable.__thumbnailWidth = thumbnailWidth;
    }

    getThumbnailHeight() {
        const self = this.getLatest();
        return self.__thumbnailHeight;
    }

    setThumbnailHeight(thumbnailHeight) {
        const writable = this.getWritable();
        return writable.__thumbnailHeight = thumbnailHeight;
    }

    setCardWidth(cardWidth) {
        const writable = this.getWritable();
        return writable.__cardWidth = cardWidth;
    }

    getCardWidth() {
        const self = this.getLatest();
        return self.__cardWidth;
    }

    getLoop() {
        const self = this.getLatest();
        return self.__loop;
    }

    setLoop(loop) {
        const writable = this.getWritable();
        return writable.__loop = loop;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }
}

const $createVideoNode = (dataset) => {
    return new VideoNode(dataset);
};

function $isVideoNode(node) {
    return node instanceof VideoNode;
}

class AudioParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isKgAudioCard = nodeElem.classList?.contains('kg-audio-card');
                if (nodeElem.tagName === 'DIV' && isKgAudioCard) {
                    return {
                        conversion(domNode) {
                            const titleNode = domNode?.querySelector('.kg-audio-title');
                            const audioNode = domNode?.querySelector('.kg-audio-player-container audio');
                            const durationNode = domNode?.querySelector('.kg-audio-duration');
                            const thumbnailNode = domNode?.querySelector('.kg-audio-thumbnail');
                            const title = titleNode && titleNode.innerHTML.trim();
                            const audioSrc = audioNode && audioNode.src;
                            const thumbnailSrc = thumbnailNode && thumbnailNode.src;
                            const durationText = durationNode && durationNode.innerHTML.trim();
                            const payload = {
                                src: audioSrc,
                                title: title
                            };
                            if (thumbnailSrc) {
                                payload.thumbnailSrc = thumbnailSrc;
                            }

                            if (durationText) {
                                const [minutes, seconds = 0] = durationText.split(':');
                                try {
                                    payload.duration = parseInt(minutes) * 60 + parseInt(seconds);
                                } catch (e) {
                                    // ignore duration
                                }
                            }

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

function renderAudioNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getSrc() || node.getSrc().trim() === '') {
        return document.createTextNode('');
    }

    return frontendTemplate$2(node, document);
}

function frontendTemplate$2(node, document) {
    let thumbnailCls = 'kg-audio-thumbnail';
    let emptyThumbnailCls = 'kg-audio-thumbnail placeholder';
    if (!node.getThumbnailSrc()) {
        thumbnailCls += ' kg-audio-hide';
    } else {
        emptyThumbnailCls += ' kg-audio-hide';
    }

    const cardDiv = document.createElement('div');
    cardDiv.setAttribute('class', 'kg-card kg-audio-card');
    const img = document.createElement('img');
    img.src = node.getThumbnailSrc();
    img.alt = 'audio-thumbnail';
    img.setAttribute('class', thumbnailCls);
    cardDiv.appendChild(img);

    const emptyThumbnailDiv = document.createElement('div');
    emptyThumbnailDiv.setAttribute('class', emptyThumbnailCls);
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '24');
    svg.setAttribute('height', '24');
    svg.setAttribute('fill', 'none');
    const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path1.setAttribute('fill-rule', 'evenodd');
    path1.setAttribute('clip-rule', 'evenodd');
    path1.setAttribute('d', 'M7.5 15.33a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm-2.25.75a2.25 2.25 0 1 1 4.5 0 2.25 2.25 0 0 1-4.5 0ZM15 13.83a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm-2.25.75a2.25 2.25 0 1 1 4.5 0 2.25 2.25 0 0 1-4.5 0Z');
    svg.appendChild(path1);
    const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path2.setAttribute('fill-rule', 'evenodd');
    path2.setAttribute('clip-rule', 'evenodd');
    path2.setAttribute('d', 'M14.486 6.81A2.25 2.25 0 0 1 17.25 9v5.579a.75.75 0 0 1-1.5 0v-5.58a.75.75 0 0 0-.932-.727.755.755 0 0 1-.059.013l-4.465.744a.75.75 0 0 0-.544.72v6.33a.75.75 0 0 1-1.5 0v-6.33a2.25 2.25 0 0 1 1.763-2.194l4.473-.746Z');
    svg.appendChild(path2);
    const path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path3.setAttribute('fill-rule', 'evenodd');
    path3.setAttribute('clip-rule', 'evenodd');
    path3.setAttribute('d', 'M3 1.5a.75.75 0 0 0-.75.75v19.5a.75.75 0 0 0 .75.75h18a.75.75 0 0 0 .75-.75V5.133a.75.75 0 0 0-.225-.535l-.002-.002-3-2.883A.75.75 0 0 0 18 1.5H3ZM1.409.659A2.25 2.25 0 0 1 3 0h15a2.25 2.25 0 0 1 1.568.637l.003.002 3 2.883a2.25 2.25 0 0 1 .679 1.61V21.75A2.25 2.25 0 0 1 21 24H3a2.25 2.25 0 0 1-2.25-2.25V2.25c0-.597.237-1.169.659-1.591Z');
    svg.appendChild(path3);
    emptyThumbnailDiv.appendChild(svg);

    cardDiv.appendChild(emptyThumbnailDiv);

    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.setAttribute('class', 'kg-audio-player-container');

    const audioElement = document.createElement('audio');
    audioElement.setAttribute('src', node.getSrc());
    audioElement.setAttribute('preload', 'metadata');
    audioPlayerContainer.appendChild(audioElement);

    const audioTitle = document.createElement('div');
    audioTitle.setAttribute('class', 'kg-audio-title');
    audioTitle.textContent = node.getTitle();
    audioPlayerContainer.appendChild(audioTitle);

    const audioPlayer = document.createElement('div');
    audioPlayer.setAttribute('class', 'kg-audio-player');
    const audioPlayIcon = document.createElement('button');
    audioPlayIcon.setAttribute('class', 'kg-audio-play-icon');
    const audioPlayIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    audioPlayIconSvg.setAttribute('viewBox', '0 0 24 24');
    const playPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    playPath.setAttribute('d', 'M23.14 10.608 2.253.164A1.559 1.559 0 0 0 0 1.557v20.887a1.558 1.558 0 0 0 2.253 1.392L23.14 13.393a1.557 1.557 0 0 0 0-2.785Z');
    audioPlayIconSvg.appendChild(playPath);
    audioPlayIcon.appendChild(audioPlayIconSvg);
    audioPlayer.appendChild(audioPlayIcon);

    const audioPauseIcon = document.createElement('button');
    audioPauseIcon.setAttribute('class', 'kg-audio-pause-icon kg-audio-hide');
    const audioPauseIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    audioPauseIconSvg.setAttribute('viewBox', '0 0 24 24');
    const rectSvg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rectSvg.setAttribute('x', '3');
    rectSvg.setAttribute('y', '1');
    rectSvg.setAttribute('width', '7');
    rectSvg.setAttribute('height', '22');
    rectSvg.setAttribute('rx', '1.5');
    rectSvg.setAttribute('ry', '1.5');
    audioPauseIconSvg.appendChild(rectSvg);
    const rectSvg2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rectSvg2.setAttribute('x', '14');
    rectSvg2.setAttribute('y', '1');
    rectSvg2.setAttribute('width', '7');
    rectSvg2.setAttribute('height', '22');
    rectSvg2.setAttribute('rx', '1.5');
    rectSvg2.setAttribute('ry', '1.5');
    audioPauseIconSvg.appendChild(rectSvg2);
    audioPauseIcon.appendChild(audioPauseIconSvg);
    audioPlayer.appendChild(audioPauseIcon);

    const audioDuration = document.createElement('span');
    audioDuration.setAttribute('class', 'kg-audio-current-time');
    audioDuration.textContent = '0:00';
    audioPlayer.appendChild(audioDuration);

    const audioDurationTotal = document.createElement('div');
    audioDurationTotal.setAttribute('class', 'kg-audio-time');
    audioDurationTotal.textContent = '/';
    const audioDUrationNode = document.createElement('span');
    audioDUrationNode.setAttribute('class', 'kg-audio-duration');
    audioDUrationNode.textContent = node.getDuration();
    audioDurationTotal.appendChild(audioDUrationNode);
    audioPlayer.appendChild(audioDurationTotal);

    const audioSlider = document.createElement('input');
    audioSlider.setAttribute('type', 'range');
    audioSlider.setAttribute('class', 'kg-audio-seek-slider');
    audioSlider.setAttribute('max', '100');
    audioSlider.setAttribute('value', '0');
    audioPlayer.appendChild(audioSlider);

    const playbackRate = document.createElement('button');
    playbackRate.setAttribute('class', 'kg-audio-playback-rate');
    playbackRate.innerHTML = '1&#215;'; // innerHTML not textContent because we need the HTML entity
    audioPlayer.appendChild(playbackRate);

    const unmuteIcon = document.createElement('button');
    unmuteIcon.setAttribute('class', 'kg-audio-unmute-icon');
    const unmuteIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    unmuteIconSvg.setAttribute('viewBox', '0 0 24 24');
    const unmutePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    unmutePath.setAttribute('d', 'M15.189 2.021a9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1.794a.249.249 0 0 1 .221.133 9.73 9.73 0 0 0 7.924 4.85h.06a1 1 0 0 0 1-1V3.02a1 1 0 0 0-1.06-.998Z');
    unmuteIconSvg.appendChild(unmutePath);
    unmuteIcon.appendChild(unmuteIconSvg);
    audioPlayer.appendChild(unmuteIcon);

    const muteIcon = document.createElement('button');
    muteIcon.setAttribute('class', 'kg-audio-mute-icon kg-audio-hide');
    const muteIconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    muteIconSvg.setAttribute('viewBox', '0 0 24 24');
    const mutePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    mutePath.setAttribute('d', 'M16.177 4.3a.248.248 0 0 0 .073-.176v-1.1a1 1 0 0 0-1.061-1 9.728 9.728 0 0 0-7.924 4.85.249.249 0 0 1-.221.133H5.25a3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h.114a.251.251 0 0 0 .177-.073ZM23.707 1.706A1 1 0 0 0 22.293.292l-22 22a1 1 0 0 0 0 1.414l.009.009a1 1 0 0 0 1.405-.009l6.63-6.631A.251.251 0 0 1 8.515 17a.245.245 0 0 1 .177.075 10.081 10.081 0 0 0 6.5 2.92 1 1 0 0 0 1.061-1V9.266a.247.247 0 0 1 .073-.176Z');
    muteIconSvg.appendChild(mutePath);
    muteIcon.appendChild(muteIconSvg);
    audioPlayer.appendChild(muteIcon);

    const volumeSlider = document.createElement('input');
    volumeSlider.setAttribute('type', 'range');
    volumeSlider.setAttribute('class', 'kg-audio-volume-slider');
    volumeSlider.setAttribute('max', '100');
    volumeSlider.setAttribute('value', '100');
    audioPlayer.appendChild(volumeSlider);

    audioPlayerContainer.appendChild(audioPlayer);
    cardDiv.appendChild(audioPlayerContainer);

    return cardDiv;
}

const INSERT_AUDIO_COMMAND = lexical.createCommand();
const NODE_TYPE$8 = 'audio';

class AudioNode extends KoenigDecoratorNode {
    // payload properties
    __src;
    __title;
    __duration;
    __mimeType;
    __thumbnailSrc;

    static getType() {
        return NODE_TYPE$8;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            src: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            src: self.__src,
            title: self.__title,
            duration: self.__duration,
            mimeType: self.__mimeType,
            thumbnailSrc: self.__thumbnailSrc
        };
    }

    constructor({src, title, duration, thumbnailSrc, mimeType} = {}, key) {
        super(key);
        this.__src = src || '';
        this.__title = title || '';
        this.__duration = duration || 0;
        this.__mimeType = mimeType || '';
        this.__thumbnailSrc = thumbnailSrc || '';
    }

    static importJSON(serializedNode) {
        const {src, title, duration, mimeType, thumbnailSrc} = serializedNode;
        const node = new this({
            src,
            title,
            mimeType,
            duration,
            thumbnailSrc
        });
        return node;
    }

    exportJSON() {
        // checks if src is a data string
        const src = this.getSrc();
        const isBlob = src.startsWith('data:');
        const dataset = {
            type: NODE_TYPE$8,
            version: 1,
            src: isBlob ? '<base64String>' : this.getSrc(),
            title: this.getTitle(),
            mimeType: this.getMimeType(),
            duration: this.getDuration(),
            thumbnailSrc: this.getThumbnailSrc()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new AudioParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderAudioNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getSrc() {
        const self = this.getLatest();
        return self.__src;
    }

    setSrc(src) {
        const writable = this.getWritable();
        return writable.__src = src;
    }

    getTitle() {
        const self = this.getLatest();
        return self.__title;
    }

    setTitle(title) {
        const writable = this.getWritable();
        return writable.__title = title;
    }

    getDuration() {
        const self = this.getLatest();
        return self.__duration;
    }

    setDuration(duration) {
        const writable = this.getWritable();
        return writable.__duration = duration;
    }

    getMimeType() {
        const self = this.getLatest();
        return self.__mimeType;
    }

    setMimeType(mimeType) {
        const writable = this.getWritable();
        return writable.__mimeType = mimeType;
    }

    getThumbnailSrc() {
        const self = this.getLatest();
        return self.__thumbnailSrc;
    }

    setThumbnailSrc(thumbnailSrc) {
        const writable = this.getWritable();
        return writable.__thumbnailSrc = thumbnailSrc;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }
}

const $createAudioNode = (dataset) => {
    return new AudioNode(dataset);
};

function $isAudioNode(node) {
    return node instanceof AudioNode;
}

function renderCalloutNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    /* c8 ignore stop */

    const document = options.createDocument();

    const element = document.createElement('div');
    element.classList.add('kg-card', 'kg-callout-card', `kg-callout-card-${node.getBackgroundColor()}`);
    if (node.getCalloutEmoji()) {
        const emojiElement = document.createElement('div');
        emojiElement.classList.add('kg-callout-emoji');
        emojiElement.textContent = node.getCalloutEmoji();
        element.appendChild(emojiElement);
    }
    const textElement = document.createElement('div');
    textElement.classList.add('kg-callout-text');
    textElement.innerHTML = node.getCalloutText();
    element.appendChild(textElement);
    return element;
}

const getColorTag = (nodeElem) => {
    const colorClass = nodeElem.classList?.value?.match(/kg-callout-card-(\w+)/);
    return colorClass && colorClass[1];
};

class CalloutParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isKgCalloutCard = nodeElem.classList?.contains('kg-callout-card');
                if (nodeElem.tagName === 'DIV' && isKgCalloutCard) {
                    return {
                        conversion(domNode) {
                            const textNode = domNode?.querySelector('.kg-callout-text');
                            const emojiNode = domNode?.querySelector('.kg-callout-emoji');
                            const color = getColorTag(domNode);

                            const payload = {
                                calloutText: textNode && textNode.innerHTML.trim(),
                                calloutEmoji: emojiNode && emojiNode.innerHTML.trim(),
                                backgroundColor: color
                            };

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

const INSERT_CALLOUT_COMMAND = lexical.createCommand();
const NODE_TYPE$7 = 'callout';

class CalloutNode extends KoenigDecoratorNode {
    // payload properties
    __calloutText;
    __calloutEmoji;
    __backgroundColor;

    static getType() {
        return NODE_TYPE$7;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    getDataset() {
        const self = this.getLatest();
        return {
            calloutText: self.__calloutText,
            calloutEmoji: self.__calloutEmoji,
            backgroundColor: self.__backgroundColor
        };
    }

    constructor({calloutText, calloutEmoji, backgroundColor} = {}, key) {
        super(key);
        this.__calloutText = calloutText || '';
        this.__calloutEmoji = calloutEmoji || '';
        this.__backgroundColor = backgroundColor || 'blue';
    }

    static importJSON(serializedNode) {
        const {calloutText, backgroundColor, calloutEmoji} = serializedNode;
        return new this({
            calloutText,
            calloutEmoji,
            backgroundColor
        });
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$7,
            version: 1,
            calloutText: this.getCalloutText(),
            calloutEmoji: this.getCalloutEmoji(),
            backgroundColor: this.getBackgroundColor()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new CalloutParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderCalloutNodeToDOM(this, options);
        return {element};
    }

    createDom() {
        const element = document.createElement('div');
        return element;
    }

    updateDom() {
        return false;
    }

    isInline() {
        return false;
    }

    getCalloutText() {
        const self = this.getLatest();
        return self.__calloutText;
    }

    setCalloutText(text) {
        const writeable = this.getWritable();
        writeable.__calloutText = text;
    }

    getBackgroundColor() {
        const self = this.getLatest();
        return self.__backgroundColor;
    }

    setBackgroundColor(color) {
        const writeable = this.getWritable();
        writeable.__backgroundColor = color;
    }

    getCalloutEmoji() {
        const self = this.getLatest();
        return self.__calloutEmoji;
    }

    setCalloutEmoji(emoji) {
        const writeable = this.getWritable();
        writeable.__calloutEmoji = emoji;
    }

    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }
}

function $isCalloutNode(node) {
    return node instanceof CalloutNode;
}

const $createCalloutNode = (dataset) => {
    return new CalloutNode(dataset);
};

class AsideParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            blockquote: () => ({
                conversion(domNode) {
                    const isBigQuote = domNode.classList?.contains('kg-blockquote-alt');
                    if (domNode.tagName === 'BLOCKQUOTE' && isBigQuote) {
                        const node = new self.NodeClass();
                        return {node};
                    }

                    return null;
                },
                priority: 0
            })
        };
    }
}

class AsideNode extends lexical.ElementNode {
    static getType() {
        return 'aside';
    }

    static clone(node) {
        return new this(
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {};
    }

    constructor(key) {
        super(key);
    }

    static importJSON(serializedNode) {
        const node = new this();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
    }

    exportJSON() {
        const dataset = {
            ...super.exportJSON(),
            type: 'aside',
            version: 1
        };
        return dataset;
    }

    static importDOM() {
        const parser = new AsideParser(this);
        return parser.DOMConversionMap;
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */
}

function $createAsideNode() {
    return new AsideNode();
}

function $isAsideNode(node) {
    return node instanceof AsideNode;
}

function renderHorizontalRuleToDOM(_, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const hr = document.createElement('hr');
    return hr;
}

class HorizontalRuleParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            hr: () => ({
                conversion() {
                    const node = new self.NodeClass();
                    return {node};
                },
                priority: 0
            })
        };
    }
}

const INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand();

class HorizontalRuleNode extends KoenigDecoratorNode {
    static getType() {
        return 'horizontalrule';
    }

    static clone(node) {
        return new this(
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {};
    }

    constructor(key) {
        super(key);
    }

    static importJSON() {
        const node = new this();
        return node;
    }

    exportJSON() {
        const dataset = {
            type: 'horizontalrule',
            version: 1
        };
        return dataset;
    }

    static importDOM() {
        const parser = new HorizontalRuleParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderHorizontalRuleToDOM(this, options);
        return {element};
    }

    getTextContent() {
        return '\n';
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

function $createHorizontalRuleNode() {
    return new HorizontalRuleNode();
}

function $isHorizontalRuleNode(node) {
    return node instanceof HorizontalRuleNode;
}

function renderHtmlNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const html = node.getHtml() || '';

    const div = document.createElement('div');

    div.innerHTML = html;

    return div;
}

class HtmlParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            '#comment': () => {
                return {
                    conversion(domNode) {
                        const isCommentNode = domNode.nodeType === 8;
                        if (isCommentNode && domNode.nodeValue.trim() === 'kg-card-begin: html') {
                            let html = [];
                            let nextNode = domNode.nextSibling;

                            while (nextNode && !isHtmlEndComment(nextNode)) {
                                let currentNode = nextNode;
                                html.push(currentNode.outerHTML);
                                nextNode = currentNode.nextSibling;
                                // remove nodes as we go so that they don't go through the parser
                                currentNode.remove();
                            }

                            let payload = {html: html.join('\n').trim()};
                            const node = new self.NodeClass(payload);
                            return {node};
                        }

                        return null;
                    },
                    priority: 0
                };
            },
            table: (nodeElem) => {
                if (nodeElem.nodeType === 1 && nodeElem.tagName === 'TABLE' && nodeElem.parentNode.tagName !== 'TABLE') {
                    return {
                        conversion(domNode) {
                            const payload = {html: domNode.outerHTML};
                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 0
                    };
                }

                return null;
            }
        };
    }
}

function isHtmlEndComment(node) {
    return node && node.nodeType === 8 && node.nodeValue === 'kg-card-end: html';
}

const INSERT_HTML_COMMAND = lexical.createCommand();

class HtmlNode extends KoenigDecoratorNode {
    __html;

    static getType() {
        return 'html';
    }

    static clone(node) {
        return new this(node.getDataset(), node.__key);
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            html: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            html: self.__html
        };
    }

    static importJSON(serializedNode) {
        const {html} = serializedNode;
        const node = new this({html});
        return node;
    }

    exportJSON() {
        return {
            type: 'html',
            version: 1,
            html: this.getHtml()
        };
    }

    constructor({html} = {}, key) {
        super(key);
        this.__html = html;
    }

    static importDOM() {
        const parser = new HtmlParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderHtmlNodeToDOM(this, options);
        return {
            element,
            type: 'inner'
        };
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getHtml() {
        const self = this.getLatest();
        return self.__html;
    }

    setHtml(html) {
        const writable = this.getWritable();
        return writable.__html = html;
    }

    // should be overwritten
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__html;
    }
}

function $createHtmlNode(dataset) {
    return new HtmlNode(dataset);
}

function $isHtmlNode(node) {
    return node instanceof HtmlNode;
}

class ToggleParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: () => ({
                conversion(domNode) {
                    const isKgToggleCard = domNode.classList?.contains('kg-toggle-card');
                    if (domNode.tagName === 'DIV' && isKgToggleCard) {
                        const headingNode = domNode.querySelector('.kg-toggle-heading-text');
                        const heading = headingNode.textContent;

                        const contentNode = domNode.querySelector('.kg-toggle-content');
                        const content = contentNode.textContent;

                        const payload = {
                            heading,
                            content
                        };

                        const node = new self.NodeClass(payload);
                        return {node};
                    }

                    return null;
                },
                priority: 1
            })
        };
    }
}

function cardTemplate$2({node}) {
    const content = node.getContent();
    const heading = node.getHeading();

    return (
        `
        <div class="kg-card kg-toggle-card" data-kg-toggle-state="close">
            <div class="kg-toggle-heading">
                <h4 class="kg-toggle-heading-text">${heading}</h4>
                <button class="kg-toggle-card-icon">
                    <svg id="Regular" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path class="cls-1" d="M23.25,7.311,12.53,18.03a.749.749,0,0,1-1.06,0L.75,7.311"></path>
                    </svg>
                </button>
            </div>
            <div class="kg-toggle-content">${content}</div>
        </div>
        `
    );
}

function emailCardTemplate$1({node}) {
    const content = node.getContent();
    const heading = node.getHeading();

    return (
        `
        <div style="background: transparent;
        border: 1px solid rgba(124, 139, 154, 0.25); border-radius: 4px; padding: 20px; margin-bottom: 1.5em;">
            <h4 style="font-size: 1.375rem; font-weight: 600; margin-bottom: 8px; margin-top:0px">${heading}</h4>
            <div style="font-size: 1rem; line-height: 1.5; margin-bottom: -1.5em;">${content}</div>
        </div>
        `
    );
}

function renderToggleNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const htmlString = options.target === 'email'
        ? emailCardTemplate$1({node})
        : cardTemplate$2({node});

    const element = document.createElement('div');
    element.innerHTML = htmlString.trim();

    return element.firstElementChild;
}

const INSERT_TOGGLE_COMMAND = lexical.createCommand();
const NODE_TYPE$6 = 'toggle';

class ToggleNode extends KoenigDecoratorNode {
    // payload properties
    __content;
    __heading;

    static getType() {
        return NODE_TYPE$6;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            content: 'html',
            heading: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            content: self.__content,
            heading: self.__heading
        };
    }

    constructor({content, heading} = {}, key) {
        super(key);
        this.__content = content || '';
        this.__heading = heading || '';
    }

    static importJSON(serializedNode) {
        const {content, heading} = serializedNode;
        return new this({
            content,
            heading
        });
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$6,
            version: 1,
            content: this.getContent(),
            heading: this.getHeading()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new ToggleParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderToggleNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getContent() {
        const self = this.getLatest();
        return self.__content;
    }

    setContent(content) {
        const writable = this.getWritable();
        return writable.__content = content;
    }

    getHeading() {
        const self = this.getLatest();
        return self.__heading;
    }

    setHeading(heading) {
        const writable = this.getWritable();
        return writable.__heading = heading;
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__heading && !this.__content;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createToggleNode = (dataset) => {
    return new ToggleNode(dataset);
};

function $isToggleNode(node) {
    return node instanceof ToggleNode;
}

class ButtonParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isButtonCard = nodeElem.classList?.contains('kg-button-card');
                if (nodeElem.tagName === 'DIV' && isButtonCard) {
                    return {
                        conversion(domNode) {
                            const alignmentClass = nodeElem.className.match(/kg-align-(left|center)/);
                            
                            let alignment;
                            if (alignmentClass) {
                                alignment = alignmentClass[1];
                            }

                            const buttonNode = domNode?.querySelector('.kg-btn');
                            const buttonUrl = buttonNode.href;
                            const buttonText = buttonNode.textContent;

                            const payload = {
                                buttonText: buttonText,
                                alignment: alignment,
                                buttonUrl: buttonUrl
                            };

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

function renderButtonNodeToDOM(node, options = {}) {
    const document = options.createDocument();

    if (!node.getButtonUrl() || node.getButtonUrl().trim() === '') {
        return document.createTextNode('');
    }

    if (options.target === 'email') {
        return emailTemplate$1(node, document);
    } else {
        return frontendTemplate$1(node, document);
    }
}

function frontendTemplate$1(node, document) {
    const cardClasses = getCardClasses$1(node);

    const cardDiv = document.createElement('div');
    cardDiv.setAttribute('class', cardClasses);

    const button = document.createElement('a');
    button.setAttribute('href', node.getButtonUrl());
    button.setAttribute('class', 'kg-btn kg-btn-accent');
    button.textContent = node.getButtonText() || 'Button Title';

    cardDiv.appendChild(button);
    return cardDiv;
}

function emailTemplate$1(node, document) {
    const parent = document.createElement('p');
    
    const buttonDiv = document.createElement('div');
    buttonDiv.setAttribute('class', 'btn btn-accent');
    parent.appendChild(buttonDiv);
    
    const table = document.createElement('table');
    table.setAttribute('border', 0);
    table.setAttribute('cellspacing', 0);
    table.setAttribute('cellpadding', 0);
    table.setAttribute('alignment',node.getAlignment());
    buttonDiv.appendChild(table);
    
    const row = document.createElement('tr');
    table.appendChild(row);
    
    const cell = document.createElement('td');
    cell.setAttribute('align', 'center');
    row.appendChild(cell);
    
    const button = document.createElement('a');
    button.setAttribute('href', node.getButtonUrl());
    button.textContent = node.getButtonText();
    cell.appendChild(button);

    return parent;
}

function getCardClasses$1(node) {
    let cardClasses = ['kg-card kg-button-card'];

    if (node.getAlignment()) {
        cardClasses.push(`kg-align-${node.getAlignment()}`);
    }

    return cardClasses.join(' ');
}

const INSERT_BUTTON_COMMAND = lexical.createCommand();

class ButtonNode extends KoenigDecoratorNode {
    // payload properties
    __buttonText;
    __alignment;
    __buttonUrl;

    static getType() {
        return 'button';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            buttonUrl: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            buttonText: self.__buttonText,
            alignment: self.__alignment,
            buttonUrl: self.__buttonUrl
        };
    }

    constructor({buttonText, alignment, buttonUrl} = {}, key) {
        super(key);
        this.__buttonText = buttonText || '';
        this.__alignment = alignment || 'center';
        this.__buttonUrl = buttonUrl || '';
    }

    static importJSON(serializedNode) {
        const {alignment, buttonText, buttonUrl} = serializedNode;
        const node = new this({
            alignment,
            buttonText,
            buttonUrl
        });
        return node;
    }

    exportJSON() {
        const dataset = {
            type: 'button',
            version: 1,
            buttonText: this.getButtonText(),
            alignment: this.getAlignment(),
            buttonUrl: this.getButtonUrl()
        };
        return dataset;
    }

    // parser used when pasting html >> node
    static importDOM() {
        const parser = new ButtonParser(this);
        return parser.DOMConversionMap;
    }

    // renderer used when copying node >> html
    exportDOM(options = {}) {
        const element = renderButtonNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getButtonText() {
        const self = this.getLatest();
        return self.__buttonText;
    }

    setButtonText(buttonText) {
        const writable = this.getWritable();
        return writable.__buttonText = buttonText;
    }

    getAlignment() {
        const self = this.getLatest();
        return self.__alignment;
    }

    setAlignment(alignment) {
        const writable = this.getWritable();
        return writable.__alignment = alignment;
    }

    getButtonUrl() {
        const self = this.getLatest();
        return self.__buttonUrl;
    }

    setButtonUrl(buttonUrl) {
        const writable = this.getWritable();
        return writable.__buttonUrl = buttonUrl;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }
}

const $createButtonNode = (dataset) => {
    return new ButtonNode(dataset);
};

function $isButtonNode(node) {
    return node instanceof ButtonNode;
}

class BookmarkParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            figure: (nodeElem) => {
                const isKgBookmarkCard = nodeElem.classList?.contains('kg-bookmark-card');
                if (nodeElem.tagName === 'FIGURE' && isKgBookmarkCard) {
                    return {
                        conversion(domNode) {
                            const url = domNode?.querySelector('.kg-bookmark-container').href;
                            const icon = domNode?.querySelector('.kg-bookmark-icon').src;
                            const title = domNode?.querySelector('.kg-bookmark-title').textContent;
                            const description = domNode?.querySelector('.kg-bookmark-description').textContent;
                            const author = domNode?.querySelector('.kg-bookmark-author').textContent;
                            const publisher = domNode?.querySelector('.kg-bookmark-publisher').textContent;
                            const thumbnail = domNode?.querySelector('.kg-bookmark-thumbnail img').src;
                            const caption = domNode?.querySelector('figure.kg-bookmark-card figcaption').textContent;
                            const payload = {
                                url: url,
                                metadata: {
                                    icon: icon,
                                    title: title,
                                    description: description,
                                    author: author,
                                    publisher: publisher,
                                    thumbnail: thumbnail
                                },
                                caption: caption
                            };
                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            },
            div: (nodeElem) => {
                if (nodeElem.nodeType === 1 && nodeElem.tagName === 'DIV' && nodeElem.className.match(/graf--mixtapeEmbed/)) {
                    return {
                        conversion(domNode) {
                            // Grab the relevant elements - Anchor wraps most of the data
                            const anchorElement = domNode.querySelector('.markup--mixtapeEmbed-anchor');
                            const titleElement = anchorElement.querySelector('.markup--mixtapeEmbed-strong');
                            const descElement = anchorElement.querySelector('.markup--mixtapeEmbed-em');
                            // Image is a top level field inside it's own a tag
                            const imgElement = domNode.querySelector('.mixtapeImage');

                            domNode.querySelector('br').remove();
                            
                            // Grab individual values from the elements
                            const url = anchorElement.href;
                            let title = '';
                            let description = '';
                            let thumbnail = '';

                            if (titleElement && titleElement.innerHTML) {
                                title = titleElement.innerHTML.trim();
                                // Cleanup anchor so we can see what's left now that we've processed title
                                anchorElement.removeChild(titleElement);
                            }
                    
                            if (descElement && descElement.innerHTML) {
                                description = descElement.innerHTML.trim();
                                // Cleanup anchor so we can see what's left now that we've processed description
                                anchorElement.removeChild(descElement);
                            }

                            // Publisher is the remaining text in the anchor, once title & desc are removed
                            let publisher = anchorElement.innerHTML.trim();

                            // Image is optional,
                            // The element usually still exists with an additional has.mixtapeImage--empty class and has no background image
                            if (imgElement && imgElement.style['background-image']) {
                                thumbnail = imgElement.style['background-image'].match(/url\(([^)]*?)\)/)[1];
                            }

                            let payload = {url, 
                                metadata: {
                                    title, 
                                    description, 
                                    publisher, 
                                    thumbnail
                                }};
                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

function renderBookmarkNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getUrl() || node.getUrl().trim() === '') {
        return document.createTextNode('');
    }

    if (options.target === 'email') {
        return emailTemplate(node, document);
    } else {
        return frontendTemplate(node, document);
    }
}

function emailTemplate(node, document) {
    const title = node.getTitle();
    const publisher = node.getPublisher();
    const author = node.getAuthor();
    const icon = node.getIconSrc();
    const description = node.getDescription();
    const url = node.getUrl();
    const thumbnail = node.getThumbnail();
    const caption = node.getCaption();

    const div = document.createElement('div');

    const html = 
        `
        <!--[if !mso !vml]-->
            <figure class="kg-card kg-bookmark-card ${caption ? `kg-card-hascaption` : ''}">
                <a class="kg-bookmark-container" href="${url}">
                    <div class="kg-bookmark-content">
                        <div class="kg-bookmark-title">${title}</div>
                        <div class="kg-bookmark-description">${description}</div>
                        <div class="kg-bookmark-metadata">
                            ${icon ? `<img class="kg-bookmark-icon" src="${icon}" alt="">` : ''}
                            ${publisher ? `<span class="kg-bookmark-publisher" src="${publisher}">${publisher}</span>` : ''}
                            ${author ? `<span class="kg-bookmark-author" src="${author}">${author}</span>` : ''}
                        </div>
                    </div>
                    ${thumbnail ? `<div class="kg-bookmark-thumbnail" style="background-image: url('${thumbnail}')">
                        <img src="${thumbnail}" alt=""></div>` : ''}
                </a>
                ${caption ? `<figcaption>${caption}</figcaption>` : ''}
            </figure>
        <!--[endif]-->
        <!--[if vml]>
            <table class="kg-card kg-bookmark-card--outlook" style="margin: 0; padding: 0; width: 100%; border: 1px solid #e5eff5; background: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; border-collapse: collapse; border-spacing: 0;" width="100%">
                <tr>
                    <td width="100%" style="padding: 20px;">
                        <table style="margin: 0; padding: 0; border-collapse: collapse; border-spacing: 0;">
                            <tr>
                                <td class="kg-bookmark-title--outlook">
                                    <a href="${url}" style="text-decoration: none; color: #15212A; font-size: 15px; line-height: 1.5em; font-weight: 600;">
                                        ${title}
                                    </a>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <div class="kg-bookmark-description--outlook">
                                        <a href="${url}" style="text-decoration: none; margin-top: 12px; color: #738a94; font-size: 13px; line-height: 1.5em; font-weight: 400;">
                                            ${description}
                                        </a>
                                    </div>
                                </td>
                            </tr>
                            <tr>
                                <td class="kg-bookmark-metadata--outlook" style="padding-top: 14px; color: #15212A; font-size: 13px; font-weight: 400; line-height: 1.5em;">
                                    <table style="margin: 0; padding: 0; border-collapse: collapse; border-spacing: 0;">
                                        <tr>
                                            ${icon ? `
                                                <td valign="middle" class="kg-bookmark-icon--outlook" style="padding-right: 8px; font-size: 0; line-height: 1.5em;">
                                                    <a href="${url}" style="text-decoration: none; color: #15212A;">
                                                        <img src="${icon}" width="22" height="22" alt=" ">
                                                    </a>
                                                </td>
                                            ` : ''}
                                            <td valign="middle" class="kg-bookmark-byline--outlook">
                                                <a href="${url}" style="text-decoration: none; color: #15212A;">
                                                    ${publisher}
                                                    ${author ? `&nbsp;&#x2022;&nbsp;` : ''}
                                                    ${author}
                                                </a>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
            <div class="kg-bookmark-spacer--outlook" style="height: 1.5em;">&nbsp;</div>
        <![endif]-->`;

    div.innerHTML = html;
    return div;
}

function frontendTemplate(node, document) {
    const card = document.createElement('figure');
    const caption = node.getCaption();
    let cardClass = 'kg-card kg-bookmark-card';
    if (caption) {
        cardClass += ' kg-card-hascaption';
    }
    card.setAttribute('class', cardClass);

    const container = document.createElement('a');
    container.setAttribute('class','kg-bookmark-container');
    container.href = node.getUrl();
    card.appendChild(container);

    const content = document.createElement('div');
    content.setAttribute('class','kg-bookmark-content');
    container.appendChild(content);

    const title = document.createElement('div');
    title.setAttribute('class','kg-bookmark-title');
    title.textContent = node.getTitle();
    content.appendChild(title);

    const description = document.createElement('div');
    description.setAttribute('class','kg-bookmark-description');
    description.textContent = node.getDescription();
    content.appendChild(description);

    const metadata = document.createElement('div');
    metadata.setAttribute('class','kg-bookmark-metadata');
    content.appendChild(metadata);

    metadata.icon = node.getIconSrc();
    if (metadata.icon) {
        const icon = document.createElement('img');
        icon.setAttribute('class','kg-bookmark-icon');
        icon.src = metadata.icon;
        icon.alt = '';
        metadata.appendChild(icon);
    }

    metadata.author = node.getAuthor();
    if (metadata.author) {
        const author = document.createElement('span');
        author.setAttribute('class','kg-bookmark-author');
        author.textContent = metadata.author;
        metadata.appendChild(author);
    }

    metadata.publisher = node.getPublisher();
    if (metadata.publisher) {
        const publisher = document.createElement('span');
        publisher.setAttribute('class','kg-bookmark-publisher');
        publisher.textContent = metadata.publisher;
        metadata.appendChild(publisher);
    }

    metadata.thumbnail = node.getThumbnail();
    if (metadata.thumbnail) {
        const thumbnailDiv = document.createElement('div');
        thumbnailDiv.setAttribute('class','kg-bookmark-thumbnail');
        container.appendChild(thumbnailDiv);

        const thumbnail = document.createElement('img');
        thumbnail.src = metadata.thumbnail;
        thumbnail.alt = '';
        thumbnailDiv.appendChild(thumbnail);
    }

    if (caption) {
        const figCaption = document.createElement('figcaption');
        figCaption.textContent = caption;
        card.appendChild(figCaption);
    }

    return card;
}

const INSERT_BOOKMARK_COMMAND = lexical.createCommand();

class BookmarkNode extends KoenigDecoratorNode {
    // payload properties
    __url;
    __icon;
    __title;
    __description;
    __author;
    __publisher;
    __thumbnail;
    __caption;

    static getType() {
        return 'bookmark';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            url: 'url',
            icon: 'url',
            thumbnail: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            url: self.__url,
            metadata: {
                icon: self.__icon,
                title: self.__title,
                description: self.__description,
                author: self.__author,
                publisher: self.__publisher,
                thumbnail: self.__thumbnail
            },
            caption: self.__caption
        
        };
    }

    constructor({url, metadata, caption} = {}, key) {
        super(key);
        this.__url = url || '';
        this.__icon = metadata?.icon || '';
        this.__title = metadata?.title || '';
        this.__description = metadata?.description || '';
        this.__author = metadata?.author || '';
        this.__publisher = metadata?.publisher || '';
        this.__thumbnail = metadata?.thumbnail || '';
        this.__caption = caption || '';
    }

    static importJSON(serializedNode) {
        const {url, metadata, caption} = serializedNode;
        const node = new this({
            url,
            metadata,
            caption
        });
        return node;
    }

    exportJSON() {
        const dataset = {
            type: 'bookmark',
            version: 1,
            url: this.getUrl(),
            metadata: {
                icon: this.getIconSrc(),
                title: this.getTitle(),
                description: this.getDescription(),
                author: this.getAuthor(),
                publisher: this.getPublisher(),
                thumbnail: this.getThumbnail()
            },
            caption: this.getCaption()
        };
        return dataset;
    }

    // parser used when pasting html >> node
    static importDOM() {
        const parser = new BookmarkParser(this);
        return parser.DOMConversionMap;
    }

    // renderer used when copying node >> html
    exportDOM(options = {}) {
        const element = renderBookmarkNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getUrl() {
        const self = this.getLatest();
        return self.__url;
    }

    setUrl(url) {
        const writable = this.getWritable();
        return writable.__url = url;
    }

    // getIcon() is reserved for the card's icon in the editor
    getIconSrc() {
        const self = this.getLatest();
        return self.__icon;
    }

    setIconSrc(icon) {
        const writable = this.getWritable();
        return writable.__icon = icon;
    }

    getTitle() {
        const self = this.getLatest();
        return self.__title;
    }

    setTitle(title) {
        const writable = this.getWritable();
        return writable.__title = title;
    }
    
    getDescription() {
        const self = this.getLatest();
        return self.__description;
    }

    setDescription(description) {
        const writable = this.getWritable();
        return writable.__description = description;
    }

    getAuthor() {
        const self = this.getLatest();
        return self.__author;
    }

    setAuthor(author) {
        const writable = this.getWritable();
        return writable.__author = author;
    }

    getPublisher() {
        const self = this.getLatest();
        return self.__publisher;
    }

    setPublisher(publisher) {
        const writable = this.getWritable();
        return writable.__publisher = publisher;
    }

    getThumbnail() {
        const self = this.getLatest();
        return self.__thumbnail;
    }

    setThumbnail(thumbnail) {
        const writable = this.getWritable();
        return writable.__thumbnail = thumbnail;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__url;
    }
}

const $createBookmarkNode = (dataset) => {
    return new BookmarkNode(dataset);
};

function $isBookmarkNode(node) {
    return node instanceof BookmarkNode;
}

function renderFileNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);
  
    const document = options.createDocument();
  
    if (!node.getSrc() || node.getSrc().trim() === '') {
        return document.createTextNode('');
    }
  
    const card = document.createElement('div');
    card.setAttribute('class', 'kg-card kg-file-card');
  
    const container = document.createElement('a');
    container.setAttribute('class', 'kg-file-card-container');
    container.setAttribute('href', node.getSrc());
    container.setAttribute('title', 'Download');
    container.setAttribute('download', '');
  
    const contents = document.createElement('div');
    contents.setAttribute('class', 'kg-file-card-contents');
  
    const title = document.createElement('div');
    title.setAttribute('class', 'kg-file-card-title');
    title.textContent = node.getFileTitle() || '';
  
    const caption = document.createElement('div');
    caption.setAttribute('class', 'kg-file-card-caption');
    caption.textContent = node.getFileCaption() || '';
  
    const metadata = document.createElement('div');
    metadata.setAttribute('class', 'kg-file-card-metadata');
  
    const filename = document.createElement('div');
    filename.setAttribute('class', 'kg-file-card-filename');
    filename.textContent = node.getFileName() || '';
  
    const filesize = document.createElement('div');
    filesize.setAttribute('class', 'kg-file-card-filesize');
    filesize.textContent = node.getFormattedFileSize() || '';
  
    metadata.appendChild(filename);
    metadata.appendChild(filesize);
  
    contents.appendChild(title);
    contents.appendChild(caption);
    contents.appendChild(metadata);
  
    container.appendChild(contents);
  
    const icon = document.createElement('div');
    icon.setAttribute('class', 'kg-file-card-icon');
  
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 24 24');
  
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  
    const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.textContent = '.a{fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;}';
  
    defs.appendChild(style);
  
    const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'title');
    titleElement.textContent = 'download-circle';
  
    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    polyline.setAttribute('class', 'a');
    polyline.setAttribute('points', '8.25 14.25 12 18 15.75 14.25');
  
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('class', 'a');
    line.setAttribute('x1', '12');
    line.setAttribute('y1', '6.75');
    line.setAttribute('x2', '12');
    line.setAttribute('y2', '18');
  
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('class', 'a');
    circle.setAttribute('cx', '12');
    circle.setAttribute('cy', '12');
    circle.setAttribute('r', '11.25');
  
    svg.appendChild(defs);
    svg.appendChild(titleElement);
    svg.appendChild(polyline);
    svg.appendChild(line);
    svg.appendChild(circle);
  
    icon.appendChild(svg);
  
    container.appendChild(icon);
  
    card.appendChild(container);
  
    return card;
}

function sizeToBytes(size) {
    if (!size) {
        return 0;
    }
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const sizeParts = size.split(' ');
    const sizeNumber = parseFloat(sizeParts[0]);
    const sizeUnit = sizeParts[1];
    const sizeUnitIndex = sizes.indexOf(sizeUnit);
    if (sizeUnitIndex === -1) {
        return 0;
    }
    return Math.round(sizeNumber * Math.pow(1024, sizeUnitIndex));
}
class FileParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isKgFileCard = nodeElem.classList?.contains('kg-file-card');
                if (nodeElem.tagName === 'DIV' && isKgFileCard) {
                    return {
                        conversion(domNode) {
                            const link = domNode.querySelector('a');
                            const src = link.getAttribute('href');
                            const fileTitle = domNode.querySelector('.kg-file-card-title')?.textContent || '';
                            const fileCaption = domNode.querySelector('.kg-file-card-caption')?.textContent || '';
                            const fileName = domNode.querySelector('.kg-file-card-filename')?.textContent || '';
                            let fileSize = sizeToBytes(domNode.querySelector('.kg-file-card-filesize')?.textContent || '');
                            const payload = {
                                src,
                                fileTitle,
                                fileCaption,
                                fileName,
                                fileSize
                            };

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

const INSERT_FILE_COMMAND = lexical.createCommand();

function bytesToSize(bytes) {
    if (!bytes) {
        return '0 Byte';
    }
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    if (bytes === 0) {
        return '0 Byte';
    }
    const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
    return Math.round((bytes / Math.pow(1024, i))) + ' ' + sizes[i];
}

class FileNode extends KoenigDecoratorNode {
    // file payload properties
    __src;
    __fileTitle;
    __fileCaption;
    __fileName;
    __fileSize;

    static getType() {
        return 'file';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            src: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            src: self.__src,
            fileTitle: self.__fileTitle,
            fileCaption: self.__fileCaption,
            fileName: self.__fileName,
            fileSize: self.__fileSize
        };
    }

    constructor({src, fileTitle, fileCaption, fileName, fileSize} = {}, key) {
        super(key);
        this.__src = src || '';
        this.__fileTitle = fileTitle || '';
        this.__fileCaption = fileCaption || '';
        this.__fileName = fileName || '';
        this.__fileSize = fileSize || '';
    }

    static importJSON(serializedNode) {
        const {src, fileTitle, fileCaption, fileName, fileSize} = serializedNode;

        return new this({
            src,
            fileTitle,
            fileCaption,
            fileName,
            fileSize
        });
    }

    exportJSON() {
        const src = this.getSrc();
        const isBlob = src.startsWith('data:');
        return {
            type: this.getType(),
            src: isBlob ? '<base64String>' : this.getSrc(),
            fileTitle: this.getFileTitle(),
            fileCaption: this.getFileCaption(),
            fileName: this.getFileName(),
            fileSize: this.getFileSize()
        };
    }

    static importDOM() {
        const parser = new FileParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderFileNodeToDOM(this, options);
        return {element};
    }

    // c8 ignore start
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }

    getSrc() {
        const self = this.getLatest();
        return self.__src;
    }

    setSrc(src) {
        const writable = this.getWritable();
        writable.__src = src;
    }

    getFileTitle() {
        const self = this.getLatest();
        return self.__fileTitle;
    }

    setFileTitle(fileTitle) {
        const writable = this.getWritable();
        writable.__fileTitle = fileTitle;
    }

    getFileCaption() {
        const self = this.getLatest();
        return self.__fileCaption;
    }

    setFileCaption(fileCaption) {
        const writable = this.getWritable();
        writable.__fileCaption = fileCaption;
    }

    getFileName() {
        const self = this.getLatest();
        return self.__fileName;
    }

    setFileName(fileName) {
        const writable = this.getWritable();
        writable.__fileName = fileName;
    }

    getFileSize() {
        const self = this.getLatest();
        return self.__fileSize;
    }

    setFileSize(size) {
        const writable = this.getWritable();
        writable.__fileSize = size;
    }

    getFormattedFileSize() {
        const self = this.getLatest();
        return bytesToSize(self.__fileSize);
    }

    hasEditMode() {
        return true;
    }
    // c8 ignore stop
    decorate() {
        return '';
    }
}

function $isFileNode(node) {
    return node instanceof FileNode;
}

const $createFileNode = (dataset) => {
    return new FileNode(dataset);
};

function slugify(str) {
    // Remove any non-word character with whitespace
    str = str.replace(/[^\w\s]/gi, '');

    // Replace any whitespace character with a dash
    str = str.replace(/\s+/g, '-');

    // Convert to lowercase
    str = str.toLowerCase();

    return str;
}

function renderHeaderNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (!node.getHeader() && !node.getSubheader() && (!node.getButtonEnabled() || (!node.getButtonUrl() || !node.getButtonText()))) {
        return document.createTextNode('');
    }

    const templateData = {
        size: node.getSize(),
        style: node.getStyle(),
        buttonEnabled: node.getButtonEnabled() && Boolean(node.getButtonUrl()) && Boolean(node.getButtonText()),
        buttonUrl: node.getButtonUrl(),
        buttonText: node.getButtonText(),
        header: node.getHeader(),
        headerSlug: slugify(node.getHeader()),
        subheader: node.getSubheader(),
        subheaderSlug: slugify(node.getSubheader()),
        hasHeader: !!node.getHeader(),
        hasSubheader: !!node.getSubheader() && !!node.getSubheader().replace(/(<br>)+$/g).trim(),
        backgroundImageStyle: node.getStyle() === 'image' ? `background-image: url(${node.getBackgroundImageSrc()})` : '',
        backgroundImageSrc: node.getBackgroundImageSrc()
    };

    const div = document.createElement('div');
    div.classList.add('kg-card', 'kg-header-card', 'kg-width-full', `kg-size-${templateData.size}`, `kg-style-${templateData.style}`);
    div.setAttribute('data-kg-background-image', templateData.backgroundImageSrc);
    div.setAttribute('style', templateData.backgroundImageStyle);

    if (templateData.hasHeader) {
        const headerElement = document.createElement('h2');
        headerElement.classList.add('kg-header-card-header');
        headerElement.setAttribute('id', templateData.headerSlug);
        headerElement.innerHTML = templateData.header;
        div.appendChild(headerElement);
    }

    if (templateData.hasSubheader) {
        const subheaderElement = document.createElement('h3');
        subheaderElement.classList.add('kg-header-card-subheader');
        subheaderElement.setAttribute('id', templateData.subheaderSlug);
        subheaderElement.innerHTML = templateData.subheader;
        div.appendChild(subheaderElement);
    }

    if (templateData.buttonEnabled) {
        const buttonElement = document.createElement('a');
        buttonElement.classList.add('kg-header-card-button');
        buttonElement.setAttribute('href', templateData.buttonUrl);
        buttonElement.textContent = templateData.buttonText;
        div.appendChild(buttonElement);
    }

    return div;
}

class HeaderParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isHeaderCard = nodeElem.classList?.contains('kg-header-card');
                if (nodeElem.tagName === 'DIV' && isHeaderCard) {
                    return {
                        conversion(domNode) {
                            const div = domNode;
                            const headerElement = domNode.querySelector('.kg-header-card-header');
                            const subheaderElement = domNode.querySelector('.kg-header-card-subheader');
                            const buttonElement = domNode.querySelector('.kg-header-card-button');
                            const size = div.classList.contains('kg-size-large') ? 'large' : 'small';
                            const style = div.classList.contains('kg-style-image') ? 'image' : 'text';
                            const backgroundImageSrc = div.getAttribute('data-kg-background-image');
                            const hasHeader = !!headerElement;
                            const header = hasHeader ? headerElement.textContent : '';
                            const headerSlug = hasHeader ? headerElement.getAttribute('id') : '';
                            const hasSubheader = !!subheaderElement;
                            const subheader = hasSubheader ? subheaderElement.textContent : '';
                            const subheaderSlug = hasSubheader ? subheaderElement.getAttribute('id') : '';
                            const buttonEnabled = !!buttonElement;
                            const buttonUrl = buttonEnabled ? buttonElement.getAttribute('href') : '';
                            const buttonText = buttonEnabled ? buttonElement.textContent : '';

                            const payload = {
                                size,
                                style,
                                backgroundImageSrc,
                                header,
                                headerSlug,
                                subheader,
                                subheaderSlug,
                                buttonEnabled,
                                buttonUrl,
                                buttonText
                            };

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

const INSERT_HEADER_COMMAND = lexical.createCommand();
const NODE_TYPE$5 = 'header';

class HeaderNode extends KoenigDecoratorNode {
    // header payload properties
    __size;
    __style;
    __buttonEnabled;
    __buttonUrl;
    __buttonText;
    __header;
    __subheader;
    __backgroundImageSrc;

    static getType() {
        return NODE_TYPE$5;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            buttonUrl: 'url',
            backgroundImageSrc: 'url',
            header: 'html',
            subheader: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            size: self.__size,
            style: self.__style,
            buttonEnabled: self.__buttonEnabled,
            buttonUrl: self.__buttonUrl,
            buttonText: self.__buttonText,
            header: self.__header,
            subheader: self.__subheader,
            backgroundImageSrc: self.__backgroundImageSrc
        };
    }

    constructor({size,
        style,
        buttonEnabled,
        buttonUrl,
        buttonText,
        header,
        subheader,
        backgroundImageSrc} = {}, key) {
        super(key);
        this.__size = size || 'small';
        this.__style = style || 'dark';
        this.__buttonEnabled = buttonEnabled || false;
        this.__buttonUrl = buttonUrl || '';
        this.__buttonText = buttonText || '';
        this.__header = header || '';
        this.__subheader = subheader || '';
        this.__backgroundImageSrc = backgroundImageSrc || '';
    }

    static importJSON(serializedNode) {
        const {size, style, buttonEnabled, buttonUrl, buttonText, header, subheader, backgroundImageSrc} = serializedNode;
        const node = new this({
            size,
            style,
            buttonEnabled,
            buttonUrl,
            buttonText,
            header,
            subheader,
            backgroundImageSrc
        });
        return node;
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$5,
            version: 1,
            size: this.getSize(),
            style: this.getStyle(),
            buttonEnabled: this.getButtonEnabled(),
            buttonUrl: this.getButtonUrl(),
            buttonText: this.getButtonText(),
            header: this.getHeader(),
            subheader: this.getSubheader(),
            backgroundImageSrc: this.getBackgroundImageSrc()
        };
        return dataset;
    }

    static importDOM() {
        const parser = new HeaderParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderHeaderNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }

    getSize() {
        const self = this.getLatest();
        return self.__size;
    }

    setSize(size) {
        const writable = this.getWritable();
        writable.__size = size;
    }

    getStyle() {
        const self = this.getLatest();
        return self.__style;
    }

    setStyle(style) {
        const writable = this.getWritable();
        writable.__style = style;
    }

    getButtonEnabled() {
        const self = this.getLatest();
        return self.__buttonEnabled;
    }

    setButtonEnabled(buttonEnabled) {
        const writable = this.getWritable();
        writable.__buttonEnabled = buttonEnabled;
    }

    getButtonUrl() {
        const self = this.getLatest();
        return self.__buttonUrl;
    }

    setButtonUrl(buttonUrl) {
        const writable = this.getWritable();
        writable.__buttonUrl = buttonUrl;
    }

    getButtonText() {
        const self = this.getLatest();
        return self.__buttonText;
    }

    setButtonText(buttonText) {
        const writable = this.getWritable();
        writable.__buttonText = buttonText;
    }

    getHeader() {
        const self = this.getLatest();
        return self.__header;
    }

    setHeader(header) {
        const writable = this.getWritable();
        writable.__header = header;
    }

    getSubheader() {
        const self = this.getLatest();
        return self.__subheader;
    }

    setSubheader(subheader) {
        const writable = this.getWritable();
        writable.__subheader = subheader;
    }

    getBackgroundImageSrc() {
        const self = this.getLatest();
        return self.__backgroundImageSrc;
    }

    setBackgroundImageSrc(backgroundImageSrc) {
        const writable = this.getWritable();
        writable.__backgroundImageSrc = backgroundImageSrc;
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.header && !this.subheader && (!this.__buttonEnabled || (!this.__buttonText && !this.__buttonUrl)) && !this.__backgroundImageSrc;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createHeaderNode = (dataset) => {
    return new HeaderNode(dataset);
};

function $isHeaderNode(node) {
    return node instanceof HeaderNode;
}

class PaywallParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            '#comment': () => {
                return {
                    conversion(domNode) {
                        const isCommentNode = domNode.nodeType === 8;
                        if (isCommentNode && domNode.nodeValue.trim() === 'members-only') {
                            const node = new self.NodeClass();
                            return {node};
                        }

                        return null;
                    },
                    priority: 0
                };
            }
        };
    }
}

function renderPaywallNodeToDOM(_, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();
    const div = document.createElement('div');

    div.innerHTML = '<!--members-only-->';

    return div;
}

const INSERT_PAYWALL_COMMAND = lexical.createCommand();
const NODE_TYPE$4 = 'paywall';

class PaywallNode extends KoenigDecoratorNode {
    static getType() {
        return NODE_TYPE$4;
    }

    static clone(node) {
        return new this(
            node.__key
        );
    }

    static get urlTransformMap() {
        return {};
    }

    constructor(key) {
        super(key);
    }

    static importJSON() {
        const node = new this();
        return node;
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$4,
            version: 1
        };
        return dataset;
    }

    static importDOM() {
        const parser = new PaywallParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderPaywallNodeToDOM(this, options);
        return {element, type: 'inner'};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createPaywallNode = (dataset) => {
    return new PaywallNode(dataset);
};

function $isPaywallNode(node) {
    return node instanceof PaywallNode;
}

class ProductParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: () => ({
                conversion(domNode) {
                    const isKgProductCard = domNode.classList?.contains('kg-product-card');
                    if (domNode.tagName === 'DIV' && isKgProductCard) {
                        const title = readCaptionFromElement(domNode, {selector: '.kg-product-card-title'});
                        const description = readCaptionFromElement(domNode, {selector: '.kg-product-card-description'});

                        const payload = {
                            productButtonEnabled: false,
                            productRatingEnabled: false,
                            productTitle: title,
                            productDescription: description
                        };

                        const img = domNode.querySelector('.kg-product-card-image');
                        if (img && img.getAttribute('src')) {
                            payload.productImageSrc = img.getAttribute('src');

                            if (img.getAttribute('width')) {
                                payload.productImageWidth = img.getAttribute('width');
                            }

                            if (img.getAttribute('height')) {
                                payload.productImageHeight = img.getAttribute('height');
                            }
                        }

                        const stars = [...domNode.querySelectorAll('.kg-product-card-rating-active')].length;
                        if (stars) {
                            payload.productRatingEnabled = true;
                            payload.productStarRating = stars;
                        }

                        const button = domNode.querySelector('a');

                        if (button) {
                            const buttonUrl = button.href;
                            const buttonText = getButtonText(button);

                            if (buttonUrl && buttonText) {
                                payload.productButtonEnabled = true;
                                payload.productButton = buttonText;
                                payload.productUrl = buttonUrl;
                            }
                        }

                        if (!title && !description && !img && !button) {
                            return null;
                        }

                        const node = new self.NodeClass(payload);
                        return {node};
                    }

                    return null;
                },
                priority: 1
            })
        };
    }
}

function getButtonText(node) {
    let buttonText = node.textContent;
    if (buttonText) {
        buttonText = buttonText.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    }
    return buttonText;
}

function renderProductNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    if (node.isEmpty()) {
        return document.createTextNode('');
    }

    const templateData = {
        ...node.getDataset(),
        starIcon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12.729,1.2l3.346,6.629,6.44.638a.805.805,0,0,1,.5,1.374l-5.3,5.253,1.965,7.138a.813.813,0,0,1-1.151.935L12,19.934,5.48,23.163a.813.813,0,0,1-1.151-.935L6.294,15.09.99,9.837a.805.805,0,0,1,.5-1.374l6.44-.638L11.271,1.2A.819.819,0,0,1,12.729,1.2Z"/></svg>`
    };

    const starActiveClasses = 'kg-product-card-rating-active';
    for (let i = 1; i <= 5; i++) {
        templateData['star' + i] = '';
        if (node.getProductStarRating() >= i) {
            templateData['star' + i] = starActiveClasses;
        }
    }

    const htmlString = options.target === 'email'
        ? emailCardTemplate({data: templateData})
        : cardTemplate$1({data: templateData});

    const element = document.createElement('div');
    element.innerHTML = htmlString.trim();

    return element.firstElementChild;
}

function cardTemplate$1({data}) {
    return (
        `
        <div class="kg-card kg-product-card">
            <div class="kg-product-card-container">
                ${data.productImageSrc ? `<img src="${data.productImageSrc}" ${data.productImageWidth ? `width="${data.productImageWidth}"` : ''} ${data.productImageHeight ? `height="${data.productImageHeight}"` : ''} class="kg-product-card-image" loading="lazy" />` : ''}
                <div class="kg-product-card-title-container">
                    <h4 class="kg-product-card-title">${data.productTitle}</h4>
                </div>
                ${data.productRatingEnabled ? `
                    <div class="kg-product-card-rating">
                        <span class="${data.star1} kg-product-card-rating-star">${data.starIcon}</span>
                        <span class="${data.star2} kg-product-card-rating-star">${data.starIcon}</span>
                        <span class="${data.star3} kg-product-card-rating-star">${data.starIcon}</span>
                        <span class="${data.star4} kg-product-card-rating-star">${data.starIcon}</span>
                        <span class="${data.star5} kg-product-card-rating-star">${data.starIcon}</span>
                    </div>
                ` : ''}

                <div class="kg-product-card-description">${data.productDescription}</div>
                ${data.productButtonEnabled ? `
                    <a href="${data.productUrl}" class="kg-product-card-button kg-product-card-btn-accent" target="_blank" rel="noopener noreferrer"><span>${data.productButton}</span></a>
                ` : ''}
            </div>
        </div>
    `
    );
}

function emailCardTemplate({data}) {
    return (
        `
         <table cellspacing="0" cellpadding="0" border="0" style="width:100%; padding:20px; border:1px solid #E9E9E9; border-radius: 5px; margin: 0 0 1.5em; width: 100%;">
            ${data.productImageSrc ? `
                <tr>
                    <td align="center" style="padding-top:0; padding-bottom:0; margin-bottom:0; padding-bottom:0;">
                        <img src="${data.productImageSrc}" ${data.productImageWidth ? `width="${data.productImageWidth}"` : ''} ${data.productImageHeight ? `height="${data.productImageHeight}"` : ''} style="height: auto; border: none; padding-bottom: 16px;" border="0">
                    </td>
                </tr>
            ` : ''}
            <tr>
                <td valign="top">
                    <h4 style="font-size: 22px !important; margin-top: 0 !important; margin-bottom: 0 !important; font-weight: 700;">${data.productTitle}</h4>
                </td>
            </tr>
            ${data.productRatingEnabled ? `
                <tr style="padding-top:0; padding-bottom:0; margin-bottom:0; padding-bottom:0;">
                    <td valign="top">
                        <img src="${`https://static.ghost.org/v4.0.0/images/star-rating-${data.productStarRating}.png`}" style="border: none; width: 96px;" border="0">
                    </td>
                </tr>
            ` : ''}
            <tr>
                <td style="padding-top:0; padding-bottom:0; margin-bottom:0; padding-bottom:0;">
                    <div style="padding-top: 8px; opacity: 0.7; font-size: 17px; line-height: 1.4; margin-bottom: -24px;">${data.productDescription}</div>
                </td>
            </tr>
            ${data.productButtonEnabled ? `
                <tr>
                    <td style="padding-top:0; padding-bottom:0; margin-bottom:0; padding-bottom:0;">
                        <div class="btn btn-accent" style="box-sizing: border-box;display: table;width: 100%;padding-top: 16px;">
                            <a href="${data.productUrl}" style="overflow-wrap: anywhere;border: solid 1px;border-radius: 5px;box-sizing: border-box;cursor: pointer;display: inline-block;font-size: 14px;font-weight: bold;margin: 0;padding: 0;text-decoration: none;color: #FFFFFF; width: 100%; text-align: center;"><span style="display: block;padding: 12px 25px;">${data.productButton}</span></a>
                        </div>
                    </td>
                </tr>
            ` : ''}
        </table>
        `
    );
}

const INSERT_PRODUCT_COMMAND = lexical.createCommand();
const NODE_TYPE$3 = 'product';

class ProductNode extends KoenigDecoratorNode {
    // payload properties
    __productImageSrc;
    __productImageWidth;
    __productImageHeight;
    __productTitle;
    __productDescription;
    __productRatingEnabled;
    __productStarRating;
    __productButtonEnabled;
    __productButton;
    __productUrl;

    static getType() {
        return NODE_TYPE$3;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            productImageSrc: 'url',
            productTitle: 'html',
            productDescription: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            productImageSrc: self.__productImageSrc,
            productImageWidth: self.__productImageWidth,
            productImageHeight: self.__productImageHeight,
            productTitle: self.__productTitle,
            productDescription: self.__productDescription,
            productRatingEnabled: self.__productRatingEnabled,
            productStarRating: self.__productStarRating,
            productButtonEnabled: self.__productButtonEnabled,
            productButton: self.__productButton,
            productUrl: self.__productUrl
        };
    }

    constructor({productImageSrc, productImageWidth, productImageHeight, productTitle, productDescription, productRatingEnabled, productStarRating, productButtonEnabled, productButton, productUrl} = {}, key) {
        super(key);
        this.__productImageSrc = productImageSrc || '';
        this.__productImageWidth = productImageWidth || null;
        this.__productImageHeight = productImageHeight || null;
        this.__productTitle = productTitle || '';
        this.__productDescription = productDescription || '';
        this.__productRatingEnabled = !!productRatingEnabled;
        this.__productStarRating = productStarRating || 5;
        this.__productButtonEnabled = !!productButtonEnabled;
        this.__productButton = productButton || '';
        this.__productUrl = productUrl || '';
    }

    static importJSON(serializedNode) {
        const {productImageSrc, productImageWidth, productImageHeight, productTitle, productDescription, productRatingEnabled, productStarRating, productButtonEnabled, productButton, productUrl} = serializedNode;
        const node = new this({
            productImageSrc,
            productImageWidth,
            productImageHeight,
            productTitle,
            productDescription,
            productRatingEnabled,
            productStarRating,
            productButtonEnabled,
            productButton,
            productUrl
        });
        return node;
    }

    exportJSON() {
        // checks if src is a data string
        const src = this.getProductImageSrc();
        const isBlob = src.startsWith('data:');
        const dataset = {
            type: NODE_TYPE$3,
            version: 1,
            productImageSrc: isBlob ? '<base64String>' : this.getProductImageSrc(),
            productImageWidth: this.getProductImageWidth(),
            productImageHeight: this.getProductImageHeight(),
            productTitle: this.getProductTitle(),
            productDescription: this.getProductDescription(),
            productRatingEnabled: this.getProductRatingEnabled(),
            productStarRating: this.getProductStarRating(),
            productButtonEnabled: this.getProductButtonEnabled(),
            productButton: this.getProductButton(),
            productUrl: this.getProductUrl()

        };
        return dataset;
    }

    static importDOM() {
        const parser = new ProductParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderProductNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getProductImageSrc() {
        const self = this.getLatest();
        return self.__productImageSrc;
    }

    setProductImageSrc(productImageSrc) {
        const writable = this.getWritable();
        return writable.__productImageSrc = productImageSrc;
    }

    getProductImageWidth() {
        const self = this.getLatest();
        return self.__productImageWidth;
    }

    setProductImageWidth(productImageWidth) {
        const writable = this.getWritable();
        return writable.__productImageWidth = productImageWidth;
    }

    getProductImageHeight() {
        const self = this.getLatest();
        return self.__productImageHeight;
    }

    setProductImageHeight(productImageHeight) {
        const writable = this.getWritable();
        return writable.__productImageHeight = productImageHeight;
    }

    getProductTitle() {
        const self = this.getLatest();
        return self.__productTitle;
    }

    setProductTitle(title) {
        const writable = this.getWritable();
        return writable.__productTitle = title;
    }

    getProductDescription() {
        const self = this.getLatest();
        return self.__productDescription;
    }

    setProductDescription(description) {
        const writable = this.getWritable();
        return writable.__productDescription = description;
    }

    getProductRatingEnabled() {
        const self = this.getLatest();
        return self.__productRatingEnabled;
    }

    setProductRatingEnabled(productRatingEnabled) {
        const writable = this.getWritable();
        return writable.__productRatingEnabled = productRatingEnabled;
    }

    getProductStarRating() {
        const self = this.getLatest();
        return self.__productStarRating;
    }

    setProductStarRating(starRating) {
        const writable = this.getWritable();
        return writable.__productStarRating = starRating;
    }

    getProductButtonEnabled() {
        const self = this.getLatest();
        return self.__productButtonEnabled;
    }

    setProductButtonEnabled(productButtonEnabled) {
        const writable = this.getWritable();
        return writable.__productButtonEnabled = productButtonEnabled;
    }

    getProductButton() {
        const self = this.getLatest();
        return self.__productButton;
    }

    setProductButton(productButton) {
        const writable = this.getWritable();
        return writable.__productButton = productButton;
    }

    getProductUrl() {
        const self = this.getLatest();
        return self.__productUrl;
    }

    setProductUrl(productUrl) {
        const writable = this.getWritable();
        return writable.__productUrl = productUrl;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        const isButtonFilled = this.__productButtonEnabled && this.__productUrl && this.__productButton;
        return !this.__productTitle && !this.__productDescription && !isButtonFilled && !this.__productImageSrc && !this.__productRatingEnabled;
    }
}

const $createProductNode = (dataset) => {
    return new ProductNode(dataset);
};

function $isProductNode(node) {
    return node instanceof ProductNode;
}

// TODO: add NFT card parser
class EmbedParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            figure: (nodeElem) => {
                if (nodeElem.nodeType === 1 && nodeElem.tagName === 'FIGURE') {
                    const iframe = nodeElem.querySelector('iframe');
                    if (iframe) {
                        return {
                            conversion(domNode) {
                                const payload = _createPayloadForIframe(iframe);

                                if (!payload) {
                                    return null;
                                }

                                payload.caption = readCaptionFromElement(domNode);

                                const node = new self.NodeClass(payload);
                                return {node};
                            },
                            priority: 1
                        };
                    }
                    const blockquote = nodeElem.querySelector('blockquote');
                    if (blockquote) {
                        return {
                            conversion(domNode) {
                                const link = domNode.querySelector('a');
                                if (!link) {
                                    return null;
                                }

                                let url = link.href;

                                // If we don't have a url, or it's not an absolute URL, we can't handle this
                                if (!url || !url.match(/^https?:\/\//i)) {
                                    return null;
                                }

                                let payload = {url: url};

                                // append caption, remove element from blockquote
                                payload.caption = readCaptionFromElement(domNode);
                                let figcaption = domNode.querySelector('figcaption');
                                figcaption?.remove();

                                payload.html = domNode.innerHTML;

                                const node = new self.NodeClass(payload);
                                return {node};
                            },
                            priority: 1
                        };
                    }
                }
                return null;
            },
            iframe: (nodeElem) => {
                if (nodeElem.nodeType === 1 && nodeElem.tagName === 'IFRAME') {
                    return {
                        conversion(domNode) {
                            const payload = _createPayloadForIframe(domNode);

                            if (!payload) {
                                return null;
                            }

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

function _createPayloadForIframe(iframe) {
    // If we don't have a src Or it's not an absolute URL, we can't handle this
    // This regex handles http://, https:// or //
    if (!iframe.src || !iframe.src.match(/^(https?:)?\/\//i)) {
        return;
    }

    // if it's a schemaless URL, convert to https
    if (iframe.src.match(/^\/\//)) {
        iframe.src = `https:${iframe.src}`;
    }

    let payload = {
        url: iframe.src
    };

    payload.html = iframe.outerHTML;

    return payload;
}

function render(node, document, options) {
    const metadata = node.getMetadata();

    const figure = document.createElement('figure');
    figure.setAttribute('class', 'kg-card kg-embed-card');

    let html = node.getHtml();  

    const tweetData = metadata && metadata.tweet_data;
    const container = document.createElement('div');
    const isEmail = options.target === 'email';

    if (tweetData && isEmail) {
        const tweetId = tweetData.id;
        const numberFormatter = new Intl.NumberFormat('en-US', {
            style: 'decimal',
            notation: 'compact',
            unitDisplay: 'narrow',
            maximumFractionDigits: 1
        });
        const retweetCount = numberFormatter.format(tweetData.public_metrics.retweet_count);
        const likeCount = numberFormatter.format(tweetData.public_metrics.like_count);
        const authorUser = tweetData.users && tweetData.users.find(user => user.id === tweetData.author_id);
        const tweetTime = luxon.DateTime.fromISO(tweetData.created_at).toLocaleString(luxon.DateTime.TIME_SIMPLE);
        const tweetDate = luxon.DateTime.fromISO(tweetData.created_at).toLocaleString(luxon.DateTime.DATE_MED);

        const mentions = tweetData.entities && tweetData.entities.mentions || [];
        const urls = tweetData.entities && tweetData.entities.urls || [];
        const hashtags = tweetData.entities && tweetData.entities.hashtags || [];
        const entities = mentions.concat(urls).concat(hashtags).sort((a, b) => a.start - b.start);
        let tweetContent = tweetData.text;

        let tweetImageUrl = null;
        const hasImageOrVideo = tweetData.attachments && tweetData.attachments && tweetData.attachments.media_keys;
        if (hasImageOrVideo) {
            tweetImageUrl = tweetData.includes.media[0].preview_image_url || tweetData.includes.media[0].url;
        }
        const hasPoll = tweetData.attachments && tweetData.attachments && tweetData.attachments.poll_ids;

        if (mentions) {
            let last = 0;
            let parts = [];
            let content = lodash.toArray(tweetContent);
            for (const entity of entities) {
                let type = 'text';
                let data = content.slice(entity.start, entity.end + 1).join('').replace(/\n/g, '<br>');
                if (entity.url) {
                    if (!entity.display_url || entity.display_url.startsWith('pic.twitter.com')) {
                        type = 'img_url';
                    } else {
                        type = 'url';
                        data = data.replace(entity.url, entity.display_url);
                    }
                }
                if (entity.username) {
                    type = 'mention';
                }
                if (entity.tag) {
                    type = 'hashtag';
                }
                parts.push({
                    type: 'text',
                    data: content.slice(last, entity.start).join('').replace(/\n/g, '<br>')
                });
                parts.push({
                    type: type,
                    data: data
                });
                last = entity.end + 1;
            }
            parts.push({
                type: 'text',
                data: content.slice(last, content.length).join('').replace(/\n/g, '<br>')
            });

            tweetContent = parts.reduce((partContent, part) => {
                if (part.type === 'text') {
                    return partContent + part.data;
                }
                if (part.type === 'mention') {
                    return partContent + `<span style="color: #1DA1F2;">${part.data}</span>`;
                }
                if (part.type === 'hashtag') {
                    return partContent + `<span style="color: #1DA1F2;">${part.data}</span>`;
                }
                if (part.type === 'url') {
                    return partContent + `<span style="color: #1DA1F2; word-break: break-all;">${part.data}</span>`;
                }
                return partContent;
            }, '');
        }

        html = `
        <table cellspacing="0" cellpadding="0" border="0" class="kg-twitter-card">
            <tr>
                <td>
                    <table cellspacing="0" cellpadding="0" border="0" width="100%">
                        ${authorUser ? `
                            <tr>
                                ${authorUser.profile_image_url ? `<td width="48" style="width: 48px;">
                                    <a href="https://twitter.com/twitter/status/${tweetId}" class="kg-twitter-link" style="padding-left: 16px; padding-top: 16px;"><img src="${authorUser.profile_image_url}" style="max-width: 512px; border: none; width: 48px; height: 48px; border-radius: 999px;" border="0"></a>
                                </td>` : ''}
                                ${authorUser.name ? `
                                <td style="line-height: 1.3em; width: 100%;">
                                    <a href="https://twitter.com/twitter/status/${tweetId}" class="kg-twitter-link" style="font-size: 15px !important; font-weight: 600; width: 100%; padding-top: 20px; padding-bottom: 18px;">${authorUser.name} <br> <span style="color: #ABB4BE; font-size: 14px; font-weight: 500;">@${authorUser.username}</span></a>
                                </td>` : ''}
                                <td align="right" width="24" style="width: 24px;">
                                    <a href="https://twitter.com/twitter/status/${tweetId}" class="kg-twitter-link" style="padding-right: 16px; padding-top: 20px; width: 24px; height: 38px;"><img src="https://static.ghost.org/v4.0.0/images/twitter-logo-small.png" width="24" border="0"></a>
                                </td>
                            </tr>
                        ` : ''}
                        <tr>
                            <td colspan="3">
                                <a href="https://twitter.com/twitter/status/${tweetId}" class="kg-twitter-link" style="font-size: 15px; line-height: 1.4em; padding-top: 8px; padding-left: 16px; padding-right: 16px; padding-bottom: 16px;">${tweetContent}
                                ${hasPoll ? `<br><span style="color: #1DA1F2;">View poll &rarr;</span>` : ''}
                                </a>
                            </td>
                        </tr>
                        ${hasImageOrVideo ? `<tr>
                            <td colspan="3" align="center" style="width: 100%;">
                                <a href="https://twitter.com/twitter/status/${tweetId}" style="display: block; padding-top: 0; padding-left: 16px; padding-right: 16px; padding-bottom: 0;"><img src="${tweetImageUrl}" style="width: 100%; border: 1px solid #E9E9E9; max-width: 528px; border-radius: 10px;" border="0"></a>
                            </td>
                        </tr>` : ''}
                        <tr>
                            <td colspan="3" style="width: 100%;">
                                <table cellspacing="0" cellpadding="0" border="0" width="100%">
                                    <tr>
                                        <td>
                                        <a href="https://twitter.com/twitter/status/${tweetId}" class="kg-twitter-link" style="padding-top: 4px; padding-right: 16px; padding-bottom: 12px; padding-left: 16px;"><span style="color: #838383;">${tweetTime} &bull; ${tweetDate}</span></a>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td colspan="3" style="width: 100%;">
                                <table cellspacing="0" cellpadding="0" border="0" width="100%" style="border-top: 1px solid #E9E9E9;">
                                    <tr>
                                        <td>
                                            <a href="https://twitter.com/twitter/status/${tweetId}" class="kg-twitter-link" style="padding-top: 12px; padding-right: 16px; padding-bottom: 12px; padding-left: 16px;">
                                                <span style="font-weight: 600;">${likeCount}</span> <span style="color: #838383;">likes &bull;</span>
                                                <span style="font-weight: 600;">${retweetCount}</span> <span style="color: #838383;">retweets</span>
                                            </a>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
        </table>
        `;
    }

    container.innerHTML = html.trim();
    figure.appendChild(container);

    const caption = node.getCaption();
    if (caption) {
        const figcaption = document.createElement('figcaption');
        figcaption.textContent = caption;
        figure.appendChild(figcaption);
        figure.setAttribute('class', `${figure.getAttribute('class')} kg-card-hascaption`);
    }

    return figure;
}

function renderEmbedNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();
    const embedType = node.getEmbedType();

    if (embedType === 'twitter') {
        return render(node, document, options);
    } 

    return renderTemplate(node, document, options);
}

function renderTemplate(node, document, options) {
    if (node.isEmpty()) {
        return document.createTextNode('');
    }
    const isEmail = options.target === 'email';
    const metadata = node.getMetadata();
    const url = node.getUrl();
    const isVideoWithThumbnail = node.getEmbedType() === 'video' && metadata && metadata.thumbnail_url;
    const figure = document.createElement('figure');
    figure.setAttribute('class', 'kg-card kg-embed-card');

    if (isEmail && isVideoWithThumbnail) {
        const emailTemplateMaxWidth = 600;
        const thumbnailAspectRatio = metadata.thumbnail_width / metadata.thumbnail_height;
        const spacerWidth = Math.round(emailTemplateMaxWidth / 4);
        const spacerHeight = Math.round(emailTemplateMaxWidth / thumbnailAspectRatio);
        const html = `
            <!--[if !mso !vml]-->
            <a class="kg-video-preview" href="${url}" aria-label="Play video" style="mso-hide: all">
                <table cellpadding="0" cellspacing="0" border="0" width="100%" background="${metadata.thumbnail_url}" role="presentation" style="background: url('${metadata.thumbnail_url}') left top / cover; mso-hide: all">
                    <tr style="mso-hide: all">
                        <td width="25%" style="visibility: hidden; mso-hide: all">
                            <img src="https://img.spacergif.org/v1/${spacerWidth}x${spacerHeight}/0a/spacer.png" alt="" width="100%" border="0" style="height: auto; opacity: 0; visibility: hidden; mso-hide: all;">
                        </td>
                        <td width="50%" align="center" valign="middle" style="vertical-align: middle; mso-hide: all;">
                            <div class="kg-video-play-button" style="mso-hide: all"><div style="mso-hide: all"></div></div>
                        </td>
                        <td width="25%" style="mso-hide: all">&nbsp;</td>
                    </tr>
                </table>
            </a>
            <!--[endif]-->

            <!--[if vml]>
            <v:group xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" coordsize="${emailTemplateMaxWidth},${spacerHeight}" coordorigin="0,0" href="${url}" style="width:${emailTemplateMaxWidth}px;height:${spacerHeight}px;">
                <v:rect fill="t" stroked="f" style="position:absolute;width:${emailTemplateMaxWidth};height:${spacerHeight};"><v:fill src="${metadata.thumbnail_url}" type="frame"/></v:rect>
                <v:oval fill="t" strokecolor="white" strokeweight="4px" style="position:absolute;left:${Math.round((emailTemplateMaxWidth / 2) - 39)};top:${Math.round((spacerHeight / 2) - 39)};width:78;height:78"><v:fill color="black" opacity="30%" /></v:oval>
                <v:shape coordsize="24,32" path="m,l,32,24,16,xe" fillcolor="white" stroked="f" style="position:absolute;left:${Math.round((emailTemplateMaxWidth / 2) - 11)};top:${Math.round((spacerHeight / 2) - 17)};width:30;height:34;" />
            </v:group>
            <![endif]-->cd ../
        `;
        figure.innerHTML = html.trim();
    } else {
        figure.innerHTML = node.getHtml();
    }
    
    const caption = node.getCaption();
    if (caption) {
        const figcaption = document.createElement('figcaption');
        figcaption.textContent = caption;
        figure.appendChild(figcaption);
        figure.setAttribute('class', `${figure.getAttribute('class')} kg-card-hascaption`);
    }

    return figure;
}

const INSERT_EMBED_COMMAND = lexical.createCommand();

class EmbedNode extends KoenigDecoratorNode {
    // payload properties
    __url;
    __embedType;
    __html;
    __metadata;
    __caption;

    static getType() {
        return 'embed';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    // used by `@tryghost/url-utils` to transform URLs contained in the serialized JSON
    static get urlTransformMap() {
        return {
            url: 'url'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            url: self.__url,
            embedType: self.__embedType,
            html: self.__html,
            metadata: self.__metadata,
            caption: self.__caption
        };
    }

    constructor({url, embedType, html, metadata, caption} = {}, key) {
        super(key);
        this.__url = url || '';
        this.__embedType = embedType || '';
        this.__html = html || '';
        this.__metadata = metadata || {};
        this.__caption = caption || '';
    }

    static importJSON(serializedNode) {
        const {url, embedType, html, metadata, caption} = serializedNode;
        const node = new this({
            url,
            embedType,
            html,
            metadata,
            caption
        });
        return node;
    }

    exportJSON() {
        const dataset = {
            type: 'embed',
            version: 1,
            url: this.getUrl(),
            embedType: this.getEmbedType(),
            html: this.getHtml(),
            metadata: this.getMetadata(),
            caption: this.getCaption()
        };
        return dataset;
    }

    // parser used when pasting html >> node
    static importDOM() {
        const parser = new EmbedParser(this);
        return parser.DOMConversionMap;
    }

    // renderer used when copying node >> html
    exportDOM(options = {}) {
        const element = renderEmbedNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getUrl() {
        const self = this.getLatest();
        return self.__url;
    }

    setUrl(url) {
        const writable = this.getWritable();
        return writable.__url = url;
    }

    getEmbedType() {
        const self = this.getLatest();
        return self.__embedType;
    }

    setEmbedType(type) {
        const writable = this.getWritable();
        return writable.__embedType = type;
    }

    getHtml() {
        const self = this.getLatest();
        return self.__html;
    }

    setHtml(html) {
        const writable = this.getWritable();
        return writable.__html = html;
    }

    getMetadata() {
        const self = this.getLatest();
        return self.__metadata;
    }

    setMetadata(metadata) {
        const writable = this.getWritable();
        return writable.__metadata = metadata;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__url && !this.__html;
    }
}

const $createEmbedNode = (dataset) => {
    return new EmbedNode(dataset);
};

function $isEmbedNode(node) {
    return node instanceof EmbedNode;
}

/**
 * Removes consecutive whitespaces and newlines
 * @param {string} html
 * @returns {string}
 */
function removeSpaces(html) {
    return html.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
}

/**
 * Wraps replacement strings with %%
 * This helps to prevent conflicts between code samples and our replacement strings
 * Example: {foo} -> %%{foo}%%
 * @param {string} html
 * @returns {string}
 */
function wrapReplacementStrings(html) {
    return html.replace(/\{(\w*?)(?:,? *"(.*?)")?\}/g, '%%$&%%');
}

function renderEmailNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);
    const document = options.createDocument();

    const html = node.getHtml();

    if (!html || options.target !== 'email') {
        return document.createTextNode('');
    }

    const cleanedHtml = wrapReplacementStrings(removeSpaces(html));
    const div = document.createElement('div');
    div.innerHTML = cleanedHtml;

    return div;
}

const INSERT_EMAIL_COMMAND = lexical.createCommand();
const NODE_TYPE$2 = 'email';

class EmailNode extends KoenigDecoratorNode {
    // payload properties
    __html;

    static getType() {
        return NODE_TYPE$2;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            html: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            html: self.__html
        };
    }

    constructor({html} = {}, key) {
        super(key);
        this.__html = html || '';
    }

    static importJSON(serializedNode) {
        const {html} = serializedNode;
        return new this({
            html
        });
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$2,
            version: 1,
            html: this.getHtml()
        };
        return dataset;
    }

    exportDOM(options = {}) {
        const element = renderEmailNodeToDOM(this, options);
        return {element, type: 'inner'};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getHtml() {
        const self = this.getLatest();
        return self.__html;
    }

    setHtml(html) {
        const writable = this.getWritable();
        return writable.__html = html;
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__html;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createEmailNode = (dataset) => {
    return new EmailNode(dataset);
};

function $isEmailNode(node) {
    return node instanceof EmailNode;
}

function readGalleryImageAttributesFromElement(element, imgNum) {
    const image = readImageAttributesFromElement(element);

    image.fileName = element.src.match(/[^/]*$/)[0];
    image.row = Math.floor(imgNum / 3);

    return image;
}

class GalleryParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            figure: (nodeElem) => {
                // Koenig gallery card
                if (nodeElem.classList?.contains('kg-gallery-card')) {
                    return {
                        conversion(domNode) {
                            const payload = {};
                            const imgs = Array.from(domNode.querySelectorAll('img'));

                            payload.images = imgs.map(readGalleryImageAttributesFromElement);
                            payload.caption = readCaptionFromElement(domNode);

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }

                return null;
            },
            div: (nodeElem) => {
                // Medium "graf" galleries
                function isGrafGallery(node) {
                    return node.tagName === 'DIV'
                        && node.dataset?.paragraphCount
                        && node.querySelectorAll('img').length > 0;
                }

                if (isGrafGallery(nodeElem)) {
                    return {
                        conversion(domNode) {
                            const payload = {
                                caption: readCaptionFromElement(domNode)
                            };

                            // These galleries exist as a series of divs containing multiple figure+img.
                            // Grab the first set of imgs...
                            let imgs = Array.from(domNode.querySelectorAll('img'));

                            // ...and then iterate over any remaining divs until we run out of matches
                            let nextNode = domNode.nextElementSibling;
                            while (nextNode && isGrafGallery(nextNode)) {
                                let currentNode = nextNode;
                                imgs = imgs.concat(Array.from(currentNode.querySelectorAll('img')));

                                const currentNodeCaption = readCaptionFromElement(currentNode);
                                if (currentNodeCaption) {
                                    payload.caption = `${payload.caption} / ${currentNodeCaption}`;
                                }

                                nextNode = currentNode.nextElementSibling;

                                // remove nodes as we go so that they don't go through the parser
                                currentNode.remove();
                            }

                            payload.images = imgs.map(readGalleryImageAttributesFromElement);

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }

                // Squarespace SQS galleries
                function isSqsGallery(node) {
                    return node.tagName === 'DIV'
                        && node.className.match(/sqs-gallery-container/)
                        && !node.className.match(/summary-/);
                }

                if (isSqsGallery(nodeElem)) {
                    return {
                        conversion(domNode) {
                            const payload = {};

                            // Each image exists twice...
                            // The first image is wrapped in `<noscript>`
                            // The second image contains image dimensions but the src property needs to be taken from `data-src`.
                            let imgs = Array.from(domNode.querySelectorAll('img.thumb-image'));

                            imgs = imgs.map((img) => {
                                if (!img.getAttribute('src')) {
                                    if (img.previousElementSibling.tagName === 'NOSCRIPT' && img.previousElementSibling.getElementsByTagName('img').length) {
                                        const prevNode = img.previousElementSibling;
                                        img.setAttribute('src', img.getAttribute('data-src'));
                                        prevNode.remove();
                                    } else {
                                        return undefined;
                                    }
                                }

                                return img;
                            }).filter(img => img !== undefined);

                            // Process nodes into the payload
                            payload.images = imgs.map(readGalleryImageAttributesFromElement);

                            payload.caption = readCaptionFromElement(domNode, {selector: '.meta-title'});

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }

                return null;
            }
        };
    }
}

const MAX_IMG_PER_ROW = 3;

function isValidImage(image) {
    return image.fileName
        && image.src
        && image.width
        && image.height;
}

function buildStructure(images) {
    const rows = [];
    const noOfImages = images.length;

    images.forEach((image, idx) => {
        let row = image.row;

        if (noOfImages > 1 && (noOfImages % MAX_IMG_PER_ROW === 1) && (idx === (noOfImages - 2))) {
            row = row + 1;
        }
        if (!rows[row]) {
            rows[row] = [];
        }

        rows[row].push(image);
    });

    return rows;
}

function renderGalleryNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);

    const document = options.createDocument();

    const validImages = node.getImages().filter(isValidImage);
    if (!validImages.length) {
        return document.createTextNode('');
    }

    const figure = document.createElement('figure');
    figure.setAttribute('class', 'kg-card kg-gallery-card kg-width-wide');

    const container = document.createElement('div');
    container.setAttribute('class', 'kg-gallery-container');
    figure.appendChild(container);

    const rows = buildStructure(validImages);

    rows.forEach((row) => {
        const rowDiv = document.createElement('div');
        rowDiv.setAttribute('class', 'kg-gallery-row');

        row.forEach((image) => {
            const imgDiv = document.createElement('div');
            imgDiv.setAttribute('class', 'kg-gallery-image');

            const img = document.createElement('img');
            img.setAttribute('src', image.src);
            img.setAttribute('width', image.width);
            img.setAttribute('height', image.height);
            img.setAttribute('loading', 'lazy');
            img.setAttribute('alt', image.alt || '');
            if (image.title) {
                img.setAttribute('title', image.title);
            }

            // images can be resized to max width, if that's the case output
            // the resized width/height attrs to ensure 3rd party gallery plugins
            // aren't affected by differing sizes
            const {canTransformImage} = options;
            const {defaultMaxWidth} = options.imageOptimization || {};
            if (
                defaultMaxWidth &&
                image.width > defaultMaxWidth &&
                isLocalContentImage(image.src, options.siteUrl) &&
                canTransformImage &&
                canTransformImage(image.src)
            ) {
                const {width, height} = resizeImage(image, {width: defaultMaxWidth});
                img.setAttribute('width', width);
                img.setAttribute('height', height);
            }

            // add srcset+sizes except for email clients which do not have good support for either
            if (options.target !== 'email') {
                setSrcsetAttribute(img, image, options);

                if (img.getAttribute('srcset') && image.width >= 720) {
                    if (rows.length === 1 && row.length === 1 && image.width >= 1200) {
                        img.setAttribute('sizes', '(min-width: 1200px) 1200px');
                    } else {
                        img.setAttribute('sizes', '(min-width: 720px) 720px');
                    }
                }
            }

            // Outlook is unable to properly resize images without a width/height
            // so we modify those to fit max width (600px) and use appropriately
            // resized images if available
            if (options.target === 'email') {
                // only resize if needed, width/height always exists for gallery image unline image cards
                if (image.width > 600) {
                    const newImageDimensions = resizeImage(image, {width: 600});
                    img.setAttribute('width', newImageDimensions.width);
                    img.setAttribute('height', newImageDimensions.height);
                }

                if (isLocalContentImage(image.src, options.siteUrl) && options.canTransformImage && options.canTransformImage(image.src)) {
                    // find available image size next up from 2x600 so we can use it for the "retina" src
                    const availableImageWidths = getAvailableImageWidths(image, options.imageOptimization.contentImageSizes);
                    const srcWidth = availableImageWidths.find(width => width >= 1200);

                    if (!srcWidth || srcWidth === image.width) ; else {
                        const [, imagesPath, filename] = image.src.match(/(.*\/content\/images)\/(.*)/);
                        img.setAttribute('src', `${imagesPath}/size/w${srcWidth}/${filename}`);
                    }
                }

                if (isUnsplashImage(image.src)) {
                    const unsplashUrl = new URL(image.src);
                    unsplashUrl.searchParams.set('w', 1200);
                    img.setAttribute('src', unsplashUrl.href);
                }
            }

            if (image.href) {
                const a = document.createElement('a');
                a.setAttribute('href', image.href);
                a.appendChild(img);
                imgDiv.appendChild(a);
            } else {
                imgDiv.appendChild(img);
            }
            rowDiv.appendChild(imgDiv);
        });

        container.appendChild(rowDiv);
    });

    if (node.getCaption()) {
        let figcaption = document.createElement('figcaption');
        figcaption.innerHTML = node.getCaption();
        figure.appendChild(figcaption);
        figure.setAttribute('class', `${figure.getAttribute('class')} kg-card-hascaption`);
    }

    return figure;
}

const INSERT_GALLERY_COMMAND = lexical.createCommand();

class GalleryNode extends KoenigDecoratorNode {
    // payload properties
    __images;
    __caption;

    static getType() {
        return 'gallery';
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            caption: 'html',
            images: {
                src: 'url',
                caption: 'html'
            }
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            images: self.__images,
            caption: self.__caption
        };
    }

    constructor({images, caption} = {}, key) {
        super(key);
        this.__images = images || [];
        this.__caption = caption || '';
    }

    static importJSON(serializedNode) {
        const {images, caption} = serializedNode;
        return new this({images, caption});
    }

    exportJSON() {
        return {
            type: 'gallery',
            version: 1,
            images: this.getImages(),
            caption: this.getCaption()
        };
    }

    static importDOM() {
        const parser = new GalleryParser(this);
        return parser.DOMConversionMap;
    }

    exportDOM(options = {}) {
        const element = renderGalleryNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        const element = document.createElement('div');
        return element;
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getImages() {
        const self = this.getLatest();
        return self.__images;
    }

    setImages(images) {
        const writable = this.getWritable();
        return writable.__images = images;
    }

    getCaption() {
        const self = this.getLatest();
        return self.__caption;
    }

    setCaption(caption) {
        const writable = this.getWritable();
        return writable.__caption = caption;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }

    hasEditMode() {
        return false;
    }
}

const $createGalleryNode = (dataset) => {
    return new GalleryNode(dataset);
};

function $isGalleryNode(node) {
    return node instanceof GalleryNode;
}

/**
 * Escape HTML special characters
 * @param {string} unsafe 
 * @returns string
 */
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

function renderEmailCtaNodeToDOM(node, options = {}) {
    addCreateDocumentOption(options);
    const document = options.createDocument();

    const html = node.getHtml();
    const buttonText = node.getButtonText();
    const buttonUrl = node.getButtonUrl();
    const showButton = node.getShowButton();
    const alignment = node.getAlignment();
    const segment = node.getSegment();
    const showDividers = node.getShowDividers();

    const hasButton = showButton && !!buttonText && !!buttonUrl;

    if ((!html && !hasButton) || options.target !== 'email') {
        return document.createTextNode('');
    }

    const container = document.createElement('div');

    if (segment) {
        container.setAttribute('data-gh-segment', segment);
    }

    if (alignment === 'center') {
        container.setAttribute('class', 'align-center');
    }

    if (showDividers) {
        container.appendChild(document.createElement('hr'));
    }

    const cleanedHtml = wrapReplacementStrings(removeSpaces(html));

    container.innerHTML = container.innerHTML + cleanedHtml;

    if (hasButton) {
        const buttonTemplate = `
            <div class="btn btn-accent">
                <table border="0" cellspacing="0" cellpadding="0" align="${escapeHtml(alignment)}">
                    <tbody>
                        <tr>
                            <td align="center">
                                <a href="${escapeHtml(buttonUrl)}">${escapeHtml(buttonText)}</a>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        `;

        const cleanedButton = wrapReplacementStrings(removeSpaces(buttonTemplate));
        container.innerHTML = container.innerHTML + cleanedButton;
    }

    if (showDividers) {
        container.appendChild(document.createElement('hr'));
    }

    return container;
}

const INSERT_EMAIL_CTA_COMMAND = lexical.createCommand();
const NODE_TYPE$1 = 'email-cta';

class EmailCtaNode extends KoenigDecoratorNode {
    // payload properties
    __alignment;
    __buttonText;
    __buttonUrl;
    __html;
    __segment;
    __showButton;
    __showDividers;

    static getType() {
        return NODE_TYPE$1;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            buttonUrl: 'url',
            html: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            alignment: self.__alignment,
            buttonText: self.__buttonText,
            buttonUrl: self.__buttonUrl,
            html: self.__html,
            segment: self.__segment,
            showButton: self.__showButton,
            showDividers: self.__showDividers
        };
    }

    constructor({alignment, buttonText, buttonUrl, html, segment, showButton, showDividers} = {}, key) {
        super(key);
        this.__alignment = alignment || 'left';
        this.__buttonText = buttonText || '';
        this.__buttonUrl = buttonUrl || '';
        this.__html = html || '';
        this.__segment = segment || 'status:free';
        this.__showButton = showButton || false;
        this.__showDividers = showDividers ?? true;
    }

    static importJSON(serializedNode) {
        const {alignment, buttonText, buttonUrl, html, segment, showButton, showDividers} = serializedNode;
        return new this({
            alignment,
            buttonText,
            buttonUrl,
            html,
            segment,
            showButton,
            showDividers
        });
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE$1,
            version: 1,
            alignment: this.getAlignment(),
            buttonText: this.getButtonText(),
            buttonUrl: this.getButtonUrl(),
            html: this.getHtml(),
            segment: this.getSegment(),
            showButton: this.getShowButton(),
            showDividers: this.getShowDividers()
        };
        return dataset;
    }

    exportDOM(options = {}) {
        const element = renderEmailCtaNodeToDOM(this, options);
        return {element};
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getAlignment() {
        const self = this.getLatest();
        return self.__alignment;
    }

    setAlignment(alignment) {
        const writable = this.getWritable();
        return writable.__alignment = alignment;
    }

    getButtonText() {
        const self = this.getLatest();
        return self.__buttonText;
    }

    setButtonText(buttonText) {
        const writable = this.getWritable();
        return writable.__buttonText = buttonText;
    }

    getButtonUrl() {
        const self = this.getLatest();
        return self.__buttonUrl;
    }

    setButtonUrl(buttonUrl) {
        const writable = this.getWritable();
        return writable.__buttonUrl = buttonUrl;
    }

    getHtml() {
        const self = this.getLatest();
        return self.__html;
    }

    setHtml(html) {
        const writable = this.getWritable();
        return writable.__html = html;
    }

    getSegment() {
        const self = this.getLatest();
        return self.__segment;
    }

    setSegment(segment) {
        const writable = this.getWritable();
        return writable.__segment = segment;
    }

    getShowButton() {
        const self = this.getLatest();
        return self.__showButton;
    }

    setShowButton(showButton) {
        const writable = this.getWritable();
        return writable.__showButton = showButton;
    }

    getShowDividers() {
        const self = this.getLatest();
        return self.__showDividers;
    }

    setShowDividers(showDividers) {
        const writable = this.getWritable();
        return writable.__showDividers = showDividers;
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__html && (!this.__showButton || (!this.__buttonText && !this.__buttonUrl));
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createEmailCtaNode = (dataset) => {
    return new EmailCtaNode(dataset);
};

function $isEmailCtaNode(node) {
    return node instanceof EmailCtaNode;
}

function rgbToHex(rgb) {
    if (rgb === 'transparent') {
        return rgb;
    }

    try {
        // Extract the red, green, and blue values from the RGB string
        const [r, g, b] = rgb.match(/\d+/g);
        // Convert each component to hexadecimal
        const red = parseInt(r, 10).toString(16).padStart(2, '0');
        const green = parseInt(g, 10).toString(16).padStart(2, '0');
        const blue = parseInt(b, 10).toString(16).padStart(2, '0');
        // Concatenate the hexadecimal values
        const hex = `#${red}${green}${blue}`;
        return hex;
    } catch (e) {
        return null;
    }
}

function getLayout(domNode) {
    if (domNode.classList.contains('kg-layout-split')) {
        return 'split';
    } else if (domNode.classList.contains('kg-layout-full')) {
        return 'full';
    } else if (domNode.classList.contains('kg-layout-wide')) {
        return 'wide';
    } else {
        return 'regular';
    }
}

class SignupParser {
    constructor(NodeClass) {
        this.NodeClass = NodeClass;
    }

    get DOMConversionMap() {
        const self = this;

        return {
            div: (nodeElem) => {
                const isSignupNode = nodeElem.dataset?.lexicalSignupForm === '';
                if (nodeElem.tagName === 'DIV' && isSignupNode) {
                    return {
                        conversion(domNode) {
                            const layout = getLayout(domNode);
                            const header = domNode.querySelector('h2')?.textContent || '';
                            const subheader = domNode.querySelector('h3')?.textContent || '';
                            const disclaimer = domNode.querySelector('p')?.textContent || '';
                            const backgroundImageSrc = layout === 'split'
                                ? domNode.querySelector('.kg-signup-card-image')?.getAttribute('src')
                                : domNode.querySelector('.kg-signup-card-container')?.getAttribute('style')?.match(/url\((.+)\)/)?.[1] || '';
                            const backgroundColor = domNode.querySelector('.kg-signup-card-container')?.style.backgroundColor || '';
                            const buttonColor = domNode.querySelector('.kg-signup-card-button')?.style.backgroundColor || '';
                            const buttonText = domNode.querySelector('.kg-signup-card-button-default')?.textContent?.trim() || 'Subscribe';
                            const buttonTextColor = domNode.querySelector('.kg-signup-card-button')?.style.color || '';
                            const textColor = domNode.querySelector('.kg-signup-card-success')?.style.color || '';
                            const alignment = domNode.querySelector('.kg-signup-card-container')?.classList.contains('align-center') ? 'center' : 'left';
                            const successMessage = domNode.querySelector('.kg-signup-card-success')?.textContent?.trim() || '';
                            const labels = [...domNode.querySelectorAll('input[data-members-label]')].map(input => input.value);

                            const isSwapped = domNode.classList.contains('kg-swapped');

                            const payload = {
                                layout,
                                buttonText,
                                header,
                                subheader,
                                disclaimer,
                                backgroundImageSrc,
                                backgroundColor: rgbToHex(backgroundColor) || 'accent',
                                buttonColor: rgbToHex(buttonColor) || '#ffffff',
                                textColor: rgbToHex(textColor) || '#ffffff',
                                buttonTextColor: rgbToHex(buttonTextColor) || '#000000',
                                alignment,
                                successMessage,
                                labels,
                                swapped: isSwapped
                            };

                            const node = new self.NodeClass(payload);
                            return {node};
                        },
                        priority: 1
                    };
                }
                return null;
            }
        };
    }
}

// ref https://ghost.org/docs/themes/members#signup-forms

function cardTemplate(nodeData) {
    const cardClasses = getCardClasses(nodeData).join(' ');

    const backgroundAccent = nodeData.backgroundColor === 'accent' ? 'kg-style-accent' : '';
    const buttonAccent = nodeData.buttonColor === 'accent' ? 'kg-style-accent' : '';
    const alignment = nodeData.alignment === 'center' ? 'align-center' : '';
    const backgroundImageStyle = nodeData.layout === 'split' ? '' : `background-image: url(${nodeData.backgroundImageSrc})`;

    const formTemplate = `
        <form class="kg-signup-card-form" data-members-form="signup">
            ${nodeData.labels.map(label => `<input data-members-label type="hidden" value="${label}" />`).join('\n')}
            <div class="kg-signup-card-fields">
                <input class="kg-signup-card-input ${buttonAccent}" style="border-color: ${nodeData.buttonColor};" id="email" data-members-email="" type="email" required="true" placeholder="yourname@example.com" />
                <button class="kg-signup-card-button ${buttonAccent}" style="background-color: ${nodeData.buttonColor}; color: ${nodeData.buttonTextColor};" type="submit">
                    <span class="kg-signup-card-button-default">${nodeData.buttonText || 'Subscribe'}</span>
                    <span class="kg-signup-card-button-loading" style="background-color: ${nodeData.buttonColor}">${loadingIcon()}</span>
                </button>
            </div>
            <div class="kg-signup-card-success" style="color: ${nodeData.textColor};">
                ${nodeData.successMessage || 'Thanks! Now check your email to confirm.'}
            </div>
                <div class="kg-signup-card-error" style="color: ${nodeData.textColor};" data-members-error></div>
        </form>
        `;

    return `
        <div class="${cardClasses}" data-lexical-signup-form style="display:none;">
            ${nodeData.layout === 'split' ? `<img class="kg-signup-card-image ${backgroundAccent}" style="background-color: ${nodeData.backgroundColor};" src="${nodeData.backgroundImageSrc}" alt="" />` : ''}
            <div class="kg-signup-card-container ${alignment} ${backgroundAccent}" style="background-color: ${nodeData.backgroundColor}; ${backgroundImageStyle}">
                <h2 class="kg-signup-card-heading" style="color: ${nodeData.textColor};">${nodeData.header}</h2>
                <h3 class="kg-signup-card-subheading" style="color: ${nodeData.textColor};">${nodeData.subheader}</h3>
                ${formTemplate}
                <p class="kg-signup-card-disclaimer" style="color: ${nodeData.textColor};">${nodeData.disclaimer}</p>
            </div>
        </div>
        `;
}

function loadingIcon() {
    return `<svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24">
        <g stroke-linecap="round" stroke-width="2" fill="currentColor" stroke="none" stroke-linejoin="round" class="nc-icon-wrapper">
            <g class="nc-loop-dots-4-24-icon-o">
                <circle cx="4" cy="12" r="3"></circle>
                <circle cx="12" cy="12" r="3"></circle>
                <circle cx="20" cy="12" r="3"></circle>
            </g>
            <style data-cap="butt">
                .nc-loop-dots-4-24-icon-o{--animation-duration:0.8s}
                .nc-loop-dots-4-24-icon-o *{opacity:.4;transform:scale(.75);animation:nc-loop-dots-4-anim var(--animation-duration) infinite}
                .nc-loop-dots-4-24-icon-o :nth-child(1){transform-origin:4px 12px;animation-delay:-.3s;animation-delay:calc(var(--animation-duration)/-2.666)}
                .nc-loop-dots-4-24-icon-o :nth-child(2){transform-origin:12px 12px;animation-delay:-.15s;animation-delay:calc(var(--animation-duration)/-5.333)}
                .nc-loop-dots-4-24-icon-o :nth-child(3){transform-origin:20px 12px}
                @keyframes nc-loop-dots-4-anim{0%,100%{opacity:.4;transform:scale(.75)}50%{opacity:1;transform:scale(1)}}
            </style>
        </g>
    </svg>`;
}

function renderSignupCardToDOM(dataset, options = {}) {
    addCreateDocumentOption(options);
    const document = options.createDocument();

    const node = {
        alignment: dataset.__alignment,
        buttonText: dataset.__buttonText,
        header: dataset.__header,
        subheader: dataset.__subheader,
        disclaimer: dataset.__disclaimer,
        backgroundImageSrc: dataset.__backgroundImageSrc,
        backgroundColor: dataset.__backgroundColor,
        buttonColor: dataset.__buttonColor,
        labels: dataset.__labels,
        layout: dataset.__layout,
        textColor: dataset.__textColor,
        buttonTextColor: dataset.__buttonTextColor,
        successMessage: dataset.__successMessage,
        swapped: dataset.__swapped
    };

    const htmlString = options.target === 'email'
        ? ''
        : cardTemplate(node);

    const element = document.createElement('div');
    element.innerHTML = htmlString?.trim();

    if (node.header === '') {
        const h2Element = element.querySelector('.kg-signup-card-heading');
        if (h2Element) {
            h2Element.remove();
        }
    }

    if (node.subheader === '') {
        const h3Element = element.querySelector('.kg-signup-card-subheading');
        if (h3Element) {
            h3Element.remove();
        }
    }

    if (node.disclaimer === '') {
        const pElement = element.querySelector('.kg-signup-card-disclaimer');
        if (pElement) {
            pElement.remove();
        }
    }
    return element.firstElementChild;
}

function getCardClasses(nodeData) {
    let cardClasses = ['kg-card kg-signup-card'];

    if (nodeData.layout && nodeData.layout !== 'split') {
        cardClasses.push(`kg-width-${nodeData.layout}`);
    }

    if (nodeData.layout === 'split') {
        cardClasses.push('kg-layout-split kg-width-full');
    }

    if (nodeData.swapped && nodeData.layout === 'split') {
        cardClasses.push('kg-swapped');
    }

    return cardClasses;
}

const INSERT_SIGNUP_COMMAND = lexical.createCommand();
const NODE_TYPE = 'signup';

class SignupNode extends KoenigDecoratorNode {
    // payload properties
    __alignment;
    __backgroundColor;
    __backgroundImageSrc;
    __textColor;
    __buttonColor;
    __buttonText;
    __buttonTextColor;
    __disclaimer;
    __header;
    __labels;
    __layout;
    __subheader;
    __successMessage;
    __swapped;

    static getType() {
        return NODE_TYPE;
    }

    static clone(node) {
        return new this(
            node.getDataset(),
            node.__key
        );
    }

    static get urlTransformMap() {
        return {
            backgroundImageSrc: 'url',
            disclaimer: 'html',
            header: 'html',
            subheader: 'html'
        };
    }

    getDataset() {
        const self = this.getLatest();
        return {
            alignment: self.__alignment,
            backgroundColor: self.__backgroundColor,
            backgroundImageSrc: self.__backgroundImageSrc,
            textColor: self.__textColor,
            buttonColor: self.__buttonColor,
            buttonText: self.__buttonText,
            buttonTextColor: self.__buttonTextColor,
            disclaimer: self.__disclaimer,
            header: self.__header,
            labels: self.__labels,
            layout: self.__layout,
            subheader: self.__subheader,
            successMessage: self.__successMessage,
            swapped: self.__swapped
        };
    }

    constructor({alignment,
        backgroundColor,
        backgroundImageSrc,
        textColor,
        buttonColor,
        buttonTextColor,
        buttonText,
        disclaimer,
        header,
        labels,
        layout,
        subheader,
        swapped,
        successMessage} = {}, key) {
        super(key);
        this.__alignment = alignment || 'left';
        this.__backgroundColor = backgroundColor || '#F4F4F4';
        this.__backgroundImageSrc = backgroundImageSrc || '';
        this.__textColor = textColor || (backgroundColor === 'transparent' ? '' : '#000000');
        this.__buttonColor = buttonColor || 'accent';
        this.__buttonTextColor = buttonTextColor || '#FFFFFF';
        this.__buttonText = buttonText || '';
        this.__disclaimer = disclaimer || '';
        this.__header = header || '';
        this.__labels = labels || [];
        this.__layout = layout || 'wide';
        this.__subheader = subheader || '';
        this.__successMessage = successMessage || 'Email sent! Check your inbox to complete your signup.';
        this.__swapped = swapped || false;
    }

    exportDOM(options = {}) {
        const element = renderSignupCardToDOM(this, options);
        return {element};
    }

    static importJSON(serializedNode) {
        const {alignment,
            backgroundColor,
            backgroundImageSrc,
            textColor,
            buttonColor,
            buttonTextColor,
            buttonText,
            disclaimer,
            header,
            labels,
            layout,
            subheader,
            swapped,
            successMessage} = serializedNode;
        const node = new this({
            alignment,
            backgroundColor,
            backgroundImageSrc,
            textColor,
            buttonColor,
            buttonTextColor,
            buttonText,
            disclaimer,
            header,
            labels,
            layout,
            subheader,
            successMessage,
            swapped
        });
        return node;
    }

    static importDOM() {
        const parser = new SignupParser(this);
        return parser.DOMConversionMap;
    }

    exportJSON() {
        const dataset = {
            type: NODE_TYPE,
            version: 1,
            alignment: this.getAlignment(),
            backgroundColor: this.getBackgroundColor(),
            backgroundImageSrc: this.getBackgroundImageSrc(),
            textColor: this.getTextColor(),
            buttonColor: this.getButtonColor(),
            buttonTextColor: this.getButtonTextColor(),
            buttonText: this.getButtonText(),
            disclaimer: this.getDisclaimer(),
            header: this.getHeader(),
            labels: this.getLabels(),
            layout: this.getLayout(),
            subheader: this.getSubheader(),
            successMessage: this.getSuccessMessage(),
            swapped: this.getSwapped()
        };
        return dataset;
    }

    /* c8 ignore start */
    createDOM() {
        return document.createElement('div');
    }

    updateDOM() {
        return false;
    }

    isInline() {
        return false;
    }
    /* c8 ignore stop */

    getAlignment() {
        const self = this.getLatest();
        return self.__alignment;
    }

    setAlignment(alignment) {
        const writable = this.getWritable();
        writable.__alignment = alignment;
    }

    getBackgroundColor() {
        const self = this.getLatest();
        return self.__backgroundColor;
    }

    setBackgroundColor(backgroundColor) {
        const writable = this.getWritable();
        writable.__backgroundColor = backgroundColor;
    }

    getBackgroundImageSrc() {
        const self = this.getLatest();
        return self.__backgroundImageSrc;
    }

    setBackgroundImageSrc(backgroundImageSrc) {
        const writable = this.getWritable();
        writable.__backgroundImageSrc = backgroundImageSrc;
    }

    getTextColor() {
        const self = this.getLatest();
        return self.__textColor;
    }

    setTextColor(textColor) {
        const writable = this.getWritable();
        writable.__textColor = textColor;
    }

    getButtonColor() {
        const self = this.getLatest();
        return self.__buttonColor;
    }

    setButtonColor(buttonColor) {
        const writable = this.getWritable();
        writable.__buttonColor = buttonColor;
    }

    getButtonTextColor() {
        const self = this.getLatest();
        return self.__buttonTextColor;
    }

    setButtonTextColor(buttonTextColor) {
        const writable = this.getWritable();
        writable.__buttonTextColor = buttonTextColor;
    }

    getButtonText() {
        const self = this.getLatest();
        return self.__buttonText;
    }

    setButtonText(buttonText) {
        const writable = this.getWritable();
        writable.__buttonText = buttonText;
    }

    getDisclaimer() {
        const self = this.getLatest();
        return self.__disclaimer;
    }

    setDisclaimer(disclaimer) {
        const writable = this.getWritable();
        writable.__disclaimer = disclaimer;
    }

    getHeader() {
        const self = this.getLatest();
        return self.__header;
    }

    setHeader(header) {
        const writable = this.getWritable();
        writable.__header = header;
    }

    getLabels() {
        const self = this.getLatest();
        return self.__labels;
    }

    setLabels(labels) {
        if (!Array.isArray(labels) || !labels.every(item => typeof item === 'string')) {
            throw new Error('Invalid argument: Expected an array of strings.'); // eslint-disable-line
        }

        const writable = this.getWritable();
        writable.__labels = labels;
    }

    addLabel(label) {
        const writable = this.getWritable();
        writable.__labels.push(label);
    }

    removeLabel(label) {
        const writable = this.getWritable();
        writable.__labels = writable.__labels.filter(l => l !== label);
    }

    getLayout() {
        const self = this.getLatest();
        return self.__layout;
    }

    setLayout(layout) {
        const writable = this.getWritable();
        writable.__layout = layout;
    }

    getSubheader() {
        const self = this.getLatest();
        return self.__subheader;
    }

    setSubheader(subheader) {
        const writable = this.getWritable();
        writable.__subheader = subheader;
    }

    getSuccessMessage() {
        const self = this.getLatest();
        return self.__successMessage;
    }

    setSuccessMessage(successMessage) {
        const writable = this.getWritable();
        writable.__successMessage = successMessage;
    }

    getSwapped() {
        const self = this.getLatest();
        return self.__swapped;
    }

    setSwapped(swapped) {
        const writable = this.getWritable();
        writable.__swapped = swapped;
    }

    hasEditMode() {
        return true;
    }

    isEmpty() {
        return !this.__backgroundColor &&
            !this.__backgroundImageSrc &&
            !this.__buttonColor &&
            !this.__buttonText &&
            !this.__disclaimer &&
            !this.__header &&
            !this.__labels.length &&
            !this.__subheader &&
            !this.__successMessage;
    }

    // should be overridden
    /* c8 ignore next 3 */
    decorate() {
        return '';
    }
}

const $createSignupNode = (dataset) => {
    return new SignupNode(dataset);
};

function $isSignupNode(node) {
    return node instanceof SignupNode;
}

// export convenience objects for use elsewhere
const DEFAULT_NODES = [
    CodeBlockNode,
    ImageNode,
    MarkdownNode,
    VideoNode,
    AudioNode,
    CalloutNode,
    AsideNode,
    HorizontalRuleNode,
    HtmlNode,
    FileNode,
    ToggleNode,
    ButtonNode,
    HeaderNode,
    BookmarkNode,
    PaywallNode,
    ProductNode,
    EmbedNode,
    EmailNode,
    GalleryNode,
    EmailCtaNode,
    SignupNode
];

exports.$createAsideNode = $createAsideNode;
exports.$createAudioNode = $createAudioNode;
exports.$createBookmarkNode = $createBookmarkNode;
exports.$createButtonNode = $createButtonNode;
exports.$createCalloutNode = $createCalloutNode;
exports.$createCodeBlockNode = $createCodeBlockNode;
exports.$createEmailCtaNode = $createEmailCtaNode;
exports.$createEmailNode = $createEmailNode;
exports.$createEmbedNode = $createEmbedNode;
exports.$createFileNode = $createFileNode;
exports.$createGalleryNode = $createGalleryNode;
exports.$createHeaderNode = $createHeaderNode;
exports.$createHorizontalRuleNode = $createHorizontalRuleNode;
exports.$createHtmlNode = $createHtmlNode;
exports.$createImageNode = $createImageNode;
exports.$createMarkdownNode = $createMarkdownNode;
exports.$createPaywallNode = $createPaywallNode;
exports.$createProductNode = $createProductNode;
exports.$createSignupNode = $createSignupNode;
exports.$createToggleNode = $createToggleNode;
exports.$createVideoNode = $createVideoNode;
exports.$isAsideNode = $isAsideNode;
exports.$isAudioNode = $isAudioNode;
exports.$isBookmarkNode = $isBookmarkNode;
exports.$isButtonNode = $isButtonNode;
exports.$isCalloutNode = $isCalloutNode;
exports.$isCodeBlockNode = $isCodeBlockNode;
exports.$isEmailCtaNode = $isEmailCtaNode;
exports.$isEmailNode = $isEmailNode;
exports.$isEmbedNode = $isEmbedNode;
exports.$isFileNode = $isFileNode;
exports.$isGalleryNode = $isGalleryNode;
exports.$isHeaderNode = $isHeaderNode;
exports.$isHorizontalRuleNode = $isHorizontalRuleNode;
exports.$isHtmlNode = $isHtmlNode;
exports.$isImageNode = $isImageNode;
exports.$isKoenigCard = $isKoenigCard;
exports.$isMarkdownNode = $isMarkdownNode;
exports.$isPaywallNode = $isPaywallNode;
exports.$isProductNode = $isProductNode;
exports.$isSignupNode = $isSignupNode;
exports.$isToggleNode = $isToggleNode;
exports.$isVideoNode = $isVideoNode;
exports.AsideNode = AsideNode;
exports.AudioNode = AudioNode;
exports.BookmarkNode = BookmarkNode;
exports.ButtonNode = ButtonNode;
exports.CalloutNode = CalloutNode;
exports.CodeBlockNode = CodeBlockNode;
exports.DEFAULT_NODES = DEFAULT_NODES;
exports.EmailCtaNode = EmailCtaNode;
exports.EmailNode = EmailNode;
exports.EmbedNode = EmbedNode;
exports.FileNode = FileNode;
exports.GalleryNode = GalleryNode;
exports.HeaderNode = HeaderNode;
exports.HorizontalRuleNode = HorizontalRuleNode;
exports.HtmlNode = HtmlNode;
exports.INSERT_AUDIO_COMMAND = INSERT_AUDIO_COMMAND;
exports.INSERT_BOOKMARK_COMMAND = INSERT_BOOKMARK_COMMAND;
exports.INSERT_BUTTON_COMMAND = INSERT_BUTTON_COMMAND;
exports.INSERT_CALLOUT_COMMAND = INSERT_CALLOUT_COMMAND;
exports.INSERT_CODE_BLOCK_COMMAND = INSERT_CODE_BLOCK_COMMAND;
exports.INSERT_EMAIL_COMMAND = INSERT_EMAIL_COMMAND;
exports.INSERT_EMAIL_CTA_COMMAND = INSERT_EMAIL_CTA_COMMAND;
exports.INSERT_EMBED_COMMAND = INSERT_EMBED_COMMAND;
exports.INSERT_FILE_COMMAND = INSERT_FILE_COMMAND;
exports.INSERT_GALLERY_COMMAND = INSERT_GALLERY_COMMAND;
exports.INSERT_HEADER_COMMAND = INSERT_HEADER_COMMAND;
exports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;
exports.INSERT_HTML_COMMAND = INSERT_HTML_COMMAND;
exports.INSERT_IMAGE_COMMAND = INSERT_IMAGE_COMMAND;
exports.INSERT_MARKDOWN_COMMAND = INSERT_MARKDOWN_COMMAND;
exports.INSERT_PAYWALL_COMMAND = INSERT_PAYWALL_COMMAND;
exports.INSERT_PRODUCT_COMMAND = INSERT_PRODUCT_COMMAND;
exports.INSERT_SIGNUP_COMMAND = INSERT_SIGNUP_COMMAND;
exports.INSERT_TOGGLE_COMMAND = INSERT_TOGGLE_COMMAND;
exports.INSERT_VIDEO_COMMAND = INSERT_VIDEO_COMMAND;
exports.ImageNode = ImageNode;
exports.ImageParser = ImageParser;
exports.KoenigDecoratorNode = KoenigDecoratorNode;
exports.MarkdownNode = MarkdownNode;
exports.PaywallNode = PaywallNode;
exports.ProductNode = ProductNode;
exports.SignupNode = SignupNode;
exports.ToggleNode = ToggleNode;
exports.UPLOAD_IMAGE_COMMAND = UPLOAD_IMAGE_COMMAND;
exports.VideoNode = VideoNode;
exports.bytesToSize = bytesToSize;
//# sourceMappingURL=kg-default-nodes.js.map
